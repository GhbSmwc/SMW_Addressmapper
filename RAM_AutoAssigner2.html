<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			select, option {
				font-family: monospace;
			}
			
			textarea {
				white-space: pre;
				overflow-wrap: normal;
				overflow-x: scroll;
			}
		</style>
	</head>
<body>


<p>This tool will take the provided freeram defines, and the list of unused RAM, and automatically find freeram and will assign each freeram defines to which address to use.</p>

<p>Make sure the supplied RAMs do not overlap.</p>

Format for freeram should be:<br>
<table><tr><td><pre>ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max</pre></td></tr></table>

Where:
<ul>
<li><kbd>ASM_resource_name</kbd> is the name of an ASM resource. Can be any character but must not contain a linebreak or tab.</li>
<li><kbd>!RAM_Define</kbd> is the define name used in the ASM file that represents a RAM to use. Just like above, no linebreaks, no tabs.</li>
<li><kbd>Number_of_bytes_Decimal</kbd> is how many bytes the RAM it requires, in decimal. Must be at least 1.</li>
<li>
	<kbd>Optional_min</kbd>: This is optional, either enter an address hex number (&ldquo;$&rdquo; is optional) or just &ldquo;-&rdquo; to nullify it. When a hex number is supplied, this forces
	the RAM to search for a freeram define to not have its starting address location below this address. This is useful if RAMs that an ASM resource must or must not reset during loading screens (black screen).
</li>
<li><kbd>Optional_max</kbd>: Same as above, but forces the location of a freeram define address not to have its ending byte greater than this address. Note: when both min and max are set, max must be greater than or equal to min.</li>
</ul>
Format for list of empty RAM should be (same as the address tracker):<br>
<table><tr><td><pre>Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description</pre></td></tr></table><br>
All of these ranges must NOT overlap.
<ul>
<li><kbd>Address</kbd> is the starting address. (dollar sign &ldquo;$&rdquo; is optional)</li>
<li><kbd>Size_or_ending_address</kbd> is the size or ending addresses (entering a decimal number results in number of bytes, and typing hyphen &ldquo;-&rdquo;, before a hexadecimal number denotes an ending address (dollar sign &ldquo;$&rdquo; is optional))</li>
<li><kbd>Optional_description</kbd> is optional, will not be checked by this javascript at all. When the remove duplicate flags is checked here, will only check the location and size/ending address.</li>
</ul><br><br>
Notes:
<ul>
	<li>This tool will process each freeram defines from top to bottom order from the text, and the list of gaps at increasing address order. This means that the RAM at the top of the list will be assigned to the lowest address location that it can fit
	(unless if not, will state no suitable address is found)</li>
</ul>

<table>
	<tr>
		<th>Enter your list of ASM resource freeram defines here.</th>
		<th>Enter your list of empty RAMs here.</th>
	</tr>
	<tr>
		<td>
			<textarea id="TextareaInput_FreeramDefines" oninput="RefreshAndMainCode()" cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
		<td>
			<textarea id="TextareaInput_EmptyRams" oninput="RefreshAndMainCode()" cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
	</tr>
</table>
<div>Sort:
<select onchange="MainCode()">
	<option id="SortSetting_None">None</option>
	<option id="SortSetting_ResourceName" selected>Resource name</option>
	<option id="SortSetting_Addr">By address</option>
	<option id="SortSetting_Length">By number of bytes</option>
</select><label><input type="checkbox">Reverse order</label><br><br>
Output format: <select onchange="MainCode()">
	<optgroup label="ASM format">
		<option id="OutputFormatSetting_ASMFormat">ASM define</option>
	</optgroup>
	<optgroup label="Address tracker format">
		<option id="OutputFormatSetting_AddressTracker">Address tracker format - length</option>
		<option id="OutputFormatSetting_AddressTracker">Address tracker format - end address</option>
	</optgroup>
</select><br><br>

Duplicate settings:
	<div><label><input type="checkbox" checked id="DuplicateSettings_Defines">Ignore duplicates for defines</label></div>
	<div><label><input type="checkbox" checked id="DuplicateSettings_EmptyRams">Ignore duplicates for defines</label></div>
</div>
<hr>
<textarea id="TextareaOutput_AssignedRAMs" cols="150" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: #FFFFFF;" readonly></textarea>
<script>
	function keyHandler_Tab(e) {

		let target;
		if (!e) e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				let startPos = target.selectionStart;
				let endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	
	[...document.querySelectorAll("textarea")].forEach(Ele => {
		Ele.addEventListener("keydown", this.keyHandler_Tab, false)
	})
	
	let Saved_Data = {
		FreeramList: [],
		EmptyRamsList: []
	}
	let NeedToUpdateLists = false
	function RefreshAndMainCode() {
		NeedToUpdateLists = true
		MainCode()
	}
	function MainCode() {
		let FreeramList = []
		let FreeramListContainsInvalidData = false
		document.getElementById("TextareaOutput_AssignedRAMs").value = ""
		if (NeedToUpdateLists) {
			let InputText = document.getElementById("TextareaInput_FreeramDefines").value
			InputText = InputText.split("\n")
			FreeramList = InputText.map((Line, Index) => {
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!(/^[^\t]+\t![a-zA-Z\d_]+\t\d+\t(?:-|-?\$?[\dA-Fa-f]+)\t(?:-|-?\$?[\dA-Fa-f]+)/).test(Line)) {
					FreeramListContainsInvalidData = true
					return {
						Type: "Error",
						Reason: "Invalid text, please check no mistyped character.",
						LineNumber: Index,
						EnteredText: Line
					}
				}
				let PartsOfString = Line.split("\t")
				let ResourceName = PartsOfString[0]
				let DefineName = PartsOfString[1]
				let Length = ParseBigIntValue(PartsOfString[2].replace(/\$/, ""))
				if (Length < 1n) {
					FreeramListContainsInvalidData = true
					return {
						Type: "Error",
						Reason: "Number of bytes must be at least 1",
						LineNumber: Index,
						EnteredText: Line
					}
				}
				let MinAddress = -Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[3])) {
					MinAddress = ParseBigIntValue(PartsOfString[3].replace(/\$/, ""), 16)
				}
				let MaxAddress = Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[4])) {
					MaxAddress = ParseBigIntValue(PartsOfString[4].replace(/\$/, ""), 16)
				}
				if (MinAddress > MaxAddress) {
					FreeramListContainsInvalidData = true
					return {
						Type: "Error",
						Reason: "Max address is before min address.",
						LineNumber: Index,
						EnteredText: Line
					}
				}
				return {
					Type: "ValidItem",
					ResourceName: ResourceName,
					DefineName: DefineName,
					Length: Length,
					MinAddress: MinAddress,
					MaxAddress: MaxAddress,
					LineNumber: Index,
					EnteredText: Line
				}
			})
			if (FreeramListContainsInvalidData) {
				let ListOfBadInputs = FreeramList.filter(Item => Item.Type=="Error")
				let ErrorText = "Error!\n"
				ListOfBadInputs.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.EnteredText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				});
				document.getElementById("TextareaOutput_AssignedRAMs").value = ErrorText
				return
			}
			FreeramList = FreeramList.filter(Item => Item.Type != "CommentOrBlankLine") //Got all our data, next, get gap data
			
			let ListOfGapsText = document.getElementById("TextareaInput_EmptyRams").value.split('\n')
			let ListOfGaps = ListOfGapsText.map((Line, Index) => {
				let SourceText = Line
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!/^\s*-?\$?[\da-fA-F]+\t(?:\d+|\~-?\$?[\da-fA-F]+)(?:\t.*)?$/.test(Line)) {
					FreeramListContainsInvalidData = true
					return {
						Type: "Error",
						Reason: "Line containing invalid information.",
						SourceText: SourceText,
						LineNumber: Index
					}
				
				}
				let LineExtracted = Line.replace(/^\s*/, "").split("\t")
				let StartAddress = ParseBigIntValue(LineExtracted[0].replace("$", ""), 16)
				let EndAddress = 0n
				let Length = 0n
				if (/^\d+$/.test(LineExtracted[1])) { //If Length is provided
					Length = ParseBigIntValue(LineExtracted[1], 10)
					EndAddress = StartAddress+Length-1n
				} else { //Otherwise if ending address provided
					EndAddress = ParseBigIntValue(LineExtracted[1].replace(/^~/, "").replace(/^\$/, ""), 16)
					Length = EndAddress-StartAddress+1n
				}
				if (Length < 1n) {
					FreeramListContainsInvalidData = true
					return {
						Type: "Error",
						Reason: "Length less than 1 byte or ending address is less than start address",
						SourceText: SourceText,
						LineNumber: Index
					}
				}
				let Description = LineExtracted[2] ?? ""
				return {
					Type: "Gap",
					LineNumber: Index,
					StartAddress: StartAddress,
					Length: Length,
					EndAddress: EndAddress,
					ConflictsWith: []
				}
			})
			if (FreeramListContainsInvalidData) {
				let ListOfBadGaps = ListOfGaps.filter(Item => Item.Type=="Error")
				let ErrorText = "Error!\n"
				ListOfBadGaps.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("TextareaOutput_AssignedRAMs").value = ErrorText
				return
			}
		}
		
		
	}
//Helper
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function BigIntToStringSignedHex(BigIntVal) {
		//Converts a bigint value into a signed ASM-styled hex number:
		//16n -> "$10"
		//-16n -> "-$10"
		let StringOutput = ""
		if (BigIntVal >= 0n) {
			StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
		} else {
			StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
		}
		return StringOutput
	}
	function DeleteCopyMessage() {
		CopiedMessage.textContent = ""
	}
</script>