<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
		</style>
	</head>
<body>
	<h1 style="text-align: center;">Byte by byte viewer</h1><br>
	
<p>This lets you view information in a byte-by-byte format (shows each consecutive neighboring addresses) and how they are used</p>

<p>Format to paste the text to view it is the same as <kbd>Addresser.html</kbd>.</p>

<textarea id="UserInputList" cols="75" rows="30" oninput="MainCode()"></textarea><br><br>
<table>
<tr>
<th><label><input type="radio" name="ViewMode" id="ViewMode_TableRangeMode" onchange="MainCode()" checked>Table range view</label></th>
<th><label><input type="radio" name="ViewMode" id="ViewMode_ByteByByte" onchange="MainCode()">Byte by byte address view</label></th>
</tr>
<tr>
<td>
<label><input type="checkbox" checked id="CleanDuplicateEntries" onchange="MainCode()"><abbr title="Any lines that are identical copies are ignored and not flagged as an overlap.">Ignore duplicates</abbr></label><br>
<label><input type="checkbox" id="EscapeHTMLTagsAndEscapes" onchange="MainCode()">Escape html tags and escape characters for table description (this prevents potential invalid opening/closing HTML tags from breaking the table).</label><br><br>

Sort by:<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_None">Keep order you sent</label><br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_StartAddress" checked>Starting address</label> (<label><input type="radio" name="Sorter" id="Sort_StartAddress_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Size">Size</label> (<label><input type="radio" name="Sorter" id="Sort_Size_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Description">Description</label> (<label><input type="radio" name="Sorter" id="Sort_Description_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Type">Gap/No overlap/Overlap</label> (<label><input type="radio" name="Sorter" id="Sort_Type_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_HowManyOverlaps">How many overlaps</label> (<label><input type="radio" name="Sorter" id="Sort_HowManyOverlaps_Reverse" onchange="MainCode()">reverse</label>)<br><br>

Filter: <button onclick="CheckAllFilters(); MainCode()">Check All</button><button onclick="UncheckAllFilters(); MainCode()">Uncheck All</button><button onclick="InvertAllFilters(); MainCode()">Invert</button><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="Gap" checked>Unused gaps</label><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="NoOverlap" checked>Used addresses that didn't overlap</label><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="Overlap" checked>Addresses that overlap</label><br><br>

Plantext size/ending address mode display:<br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Size"checked>Size</label><br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Ending">Ending</label><br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Both">Size and ending (<kbd>&lt;size&gt;/-&lt;ending_address&gt;</kbd>)</label><br>
<label><input type="checkbox" onchange="MainCode()" id="ShowStatusOfData">Show status of ram usage (gap, overlap, and no-overlaps)</label>
</td>
<td>
Address to view: $<input type="text" class="AnyRadixNumberInput" data-input_number_radix="16" id="ByteByByteViewStartingAddress" onchange="MainCode()" value="7E0000">
</td>
</tr>
</table>
<hr>
<br><br>
<span id="OutputSpanTag"></span>
<script>
//Tab key
//Tab key to make it not switch the focus and actually insert a tab character.
	window.onload = function(){    
		UpDownArrowKeysIncrement()
		var addressList = document.getElementById("UserInputList");
		if(addressList.addEventListener ) {
			addressList.addEventListener('keydown',this.keyHandler_Tab,false);
		} else if(addressList.attachEvent ) {
			addressList.attachEvent('onkeydown',this.keyHandler_Tab);
		}
	}

	function keyHandler_Tab(e) {

		var target;
		if (!e) var e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				var startPos = target.selectionStart;
				var endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
//Filter checkbox functions
	function CheckAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = 1
		}
	}
	function UncheckAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = 0
		}
	}
	function InvertAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = ListOfFilters[Index].checked ^ 1
		}
	}
//Settings (akin to defines settings)
	const Setting_ByteView_SVGGridSizeFactor = 16n
	const Setting_ByteView_AddressColumnPosition = 5n		//Note: right-aligned, from text-anchor, position of the right edge of text
	const Setting_ByteView_BarsXPosStart = 5n			//Note: left-aligned, position from left edge.
	const Setting_ByteView_NumberOfRows = 100n
	const Setting_ByteView_NumberOfColumns = 20n			//Width of viewbox, that, multiplied by Setting_ByteView_SVGGridSizeFactor
//Regex stuff
	String2Regex_CorrectLine = "^\\$?[0-9A-Fa-f]+\\t(\\d+|-\\$?[0-9A-Fa-f]+)(\\t[^\\t]*?)?$"
	String2Regex_GetStartingAddress = "(?<=^\\$?)[0-9A-Fa-f]+"
	String2Regex_GetNumberOfBytesOrEndingAddress = "(?<=^\\$?[0-9A-Fa-f]+\\t)(\\d+|-\\$?[0-9A-Fa-f]+)"
	String2Regex_GetDiscription = "(?<=^[^\\t]+\\t[^\\t]+\\t)[^\\t]+$"
//Main functions
	function MainCode() {
		let OutputHTML = ""
		let ListOfAddress = new Array()
	//Some input data
		let StartAddressView = ParseBigIntValue(document.getElementById("ByteByByteViewStartingAddress").value, 16)
		if (StartAddressView < 0n) {
			StartAddressView = 0n
		}
		document.getElementById("ByteByByteViewStartingAddress").value = StartAddressView.toString(16).toUpperCase()
	//Get each line of text, will ignore items with just spaces, or spaces followed by comma.
		let UserInputList = RemoveBlankCommentOrSpacesEntry(document.getElementById("UserInputList").value.split('\n'))
	//Check if all lines are correct.
		let IsAllStringsValid = true
		for (let Index = 0; Index < UserInputList.length; Index++) {
			if (!(RegExp(String2Regex_CorrectLine).test(UserInputList[Index]))) {
				IsAllStringsValid = false
			}
		}
		if (IsAllStringsValid) {
			//Verify that the number of bytes/ending address are correct.
			//Number of bytes should be at least 1, and ending address not to be less than the starting address.
			//Easy way is to have them all be number of bytes.
			
			//However, we need to convert the first two columns, the address and the number of bytes or ending address
			//first.
				for (let Index = 0; Index < UserInputList.length; Index++) {
					let StartAddress = BigInt("0x" + UserInputList[Index].match(RegExp(String2Regex_GetStartingAddress))[0])
					let NumbOfBytesOrEndAddress_String = UserInputList[Index].match(RegExp(String2Regex_GetNumberOfBytesOrEndingAddress))[0]
					let NumberOfBytes = 0n
					if ((/^\d+$/).test(NumbOfBytesOrEndAddress_String)) {
						NumberOfBytes = BigInt(NumbOfBytesOrEndAddress_String)
					} else {
						let EndingAddressString = NumbOfBytesOrEndAddress_String.replace(/-\$?/, "")
						NumberOfBytes = BigInt("0x" + EndingAddressString) - StartAddress + 1n
					}
					let Description = ""
					if ((RegExp(String2Regex_GetDiscription)).test(UserInputList[Index])) {
						Description += UserInputList[Index].match(RegExp(String2Regex_GetDiscription))[0]
					}
					ListOfAddress.push([StartAddress, NumberOfBytes, Description, [], -1, "NoOverlap", 0n])
				}
			//Clean duplicates
				if (document.getElementById("CleanDuplicateEntries").checked) {
					ListOfAddress = RemoveDuplicateAddressEntry(ListOfAddress)
				}
			//Number the items (excluding duplicates when that checkbox is checked)
				for (let Index = 0; Index < ListOfAddress.length; Index++) {
					ListOfAddress[Index][4] = Index
				}
			//ListOfAddress[Index] now contains an array:
			//ListOfAddress[Index][0] = starting address
			//ListOfAddress[Index][1] = number of bytes
			//ListOfAddress[Index][2] = description
			//ListOfAddress[Index][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
			//ListOfAddress[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0. If -1n, then it's generated by this JS for gaps.
			//ListOfAddress[Index][5] = Status/type ("NoOverlap", "Overlap" "Gap")
			//ListOfAddress[Index][6] = Horizontal position for SVG bar placement.
			//Let's check if any had wrong number of bytes or ending address
				let IsNumberOfBytesCorrectOnAll = true
				for (let Index = 0; (Index < ListOfAddress.length&& IsNumberOfBytesCorrectOnAll == true); Index++) {
					if (ListOfAddress[Index][1] < 1n) {
						IsNumberOfBytesCorrectOnAll = false
					}
				}
			//If all number of bytes are valid
				if (IsNumberOfBytesCorrectOnAll) {
					//Check if any address overlaps another
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							for (let Index2 = Index + 1; Index2 < ListOfAddress.length; Index2++) {
								if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)) {
									//Write each other's overlap list
										ListOfAddress[Index][3].push(ListOfAddress[Index2][4])
										ListOfAddress[Index2][3].push(ListOfAddress[Index][4])
									//Mark they're overlapping
										ListOfAddress[Index][5] = "Overlap"
										ListOfAddress[Index2][5] = "Overlap"
								}
							}
						}
					//Get list of gaps
						let Count_Gap = 0
							{
								//let ArrayCopyButSortedForGapFinding = ListOfAddress.sort(SortByStartAddr) <-This will sort BOTH arrays.
								// Needed in case if we have multiple overlapping address. When having multiple overlapping addresses, the ending address
								// of the last range processed is NOT always the last byte, if we had (1st) one address, and then another (2nd) but shorter range,
								// we wouldn't want to use the ending address of 2nd because we look at the address after the last byte of whoever is the longest.
								// Made up example:
								//  7E0060-7E0063	;>First
								//  7E0061-7E0062	;>Second
								// 7E0063 is what we assume the last byte, not 7E0062. Essentially, HighestEndAddressGapDetect holds the highest ending address
								// currently processed that overlaps.
									let HighestEndAddressGapDetect = -1n
									let GapAddressList = new Array()
								let ArrayCopyButSortedForGapFinding = ListOfAddress
								ArrayCopyButSortedForGapFinding.sort(SortByStartAddr)
								for (let Index = 1; Index < ArrayCopyButSortedForGapFinding.length; Index++) {
									//If the highest index exceeds HighestEndAddressGapDetect, replace it with the higher number
										if (ArrayCopyButSortedForGapFinding[Index - 1][0] + ArrayCopyButSortedForGapFinding[Index - 1][1] - 1n > HighestEndAddressGapDetect) {
											HighestEndAddressGapDetect = ArrayCopyButSortedForGapFinding[Index - 1][0] + ArrayCopyButSortedForGapFinding[Index - 1][1] - 1n
										}
										if (ArrayCopyButSortedForGapFinding[Index][0] > HighestEndAddressGapDetect + 1n) {
											//Create an array containing between-range gap addresses.
												GapAddressList.push([(HighestEndAddressGapDetect + 1n), (ArrayCopyButSortedForGapFinding[Index][0] - HighestEndAddressGapDetect - 1n), "Gap", [], -1n, "Gap", 0n])
												//ListOfGaps.push(GapArray)
										}
										
								}
								for (let Index = 0; Index < GapAddressList.length; Index++) {
									ListOfAddress.push(GapAddressList[Index])
								}
								Count_Gap = GapAddressList.length
							}
					//Statistics
						let Count_TotalNumberOfRanges_PriorFilter = ListOfAddress.length
						let Count_Overlap = 0
						let Count_NoOverlap = 0
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							if (ListOfAddress[Index][5] == "Overlap") {
								Count_Overlap++
							}
							if (ListOfAddress[Index][5] == "NoOverlap") {
								Count_NoOverlap++
							}
						}
						if (document.getElementById("ViewMode_TableRangeMode").checked) {
							//Filter
								ListOfAddress = FilterAddress(ListOfAddress)
							//Sort it
								if (document.getElementById("Sort_StartAddress").checked) {
									ListOfAddress.sort(SortByStartAddr)
								} else if (document.getElementById("Sort_StartAddress_Reverse").checked) {
									ListOfAddress.sort(SortByStartAddrRev)
								} else if (document.getElementById("Sort_Size").checked) {
									ListOfAddress.sort(SortBySize)
								} else if (document.getElementById("Sort_Size_Reverse").checked) {
									ListOfAddress.sort(SortBySizeRev)
								} else if (document.getElementById("Sort_Description").checked) {
									ListOfAddress.sort(SortByDescription)
								} else if (document.getElementById("Sort_Type").checked) {
									ListOfAddress.sort(SortByStatus)
								} else if (document.getElementById("Sort_Type_Reverse").checked) {
									ListOfAddress.sort(SortByStatusRev)
								} else if (document.getElementById("Sort_Description_Reverse").checked) {
									ListOfAddress.sort(SortByDescriptionRev)
								} else if (document.getElementById("Sort_HowManyOverlaps").checked) {
									ListOfAddress.sort(SortByOverlapCount)
								} else if (document.getElementById("Sort_HowManyOverlaps_Reverse").checked) {
									ListOfAddress.sort(SortByOverlapCountRev)
								}
							//Now display it
								//Statistics
									OutputHTML += "<ul>"
									OutputHTML += "<li><kbd>Total number of ranges found (including gaps): " + BigInt(Count_TotalNumberOfRanges_PriorFilter).toString(10) + "</kbd></li>"
									OutputHTML += "<ul>"
									OutputHTML += "<li><kbd style='color: #00FF00'>Number of used RAM ranges not overlapping: " + BigInt(Count_NoOverlap).toString(10) + "</kbd></li>"
									OutputHTML += "<li><kbd style='color: #FF0000'>Number of used RAM ranges overlapping: " + BigInt(Count_Overlap).toString(10) + "</kbd></li>"
									OutputHTML += "<li><kbd style='color: #808080'>Number of gaps: " + BigInt(Count_Gap).toString(10) + "</kbd></li>"
									OutputHTML += "</ul>"
									OutputHTML += "</ul><br><br>"
								//how many shown
									OutputHTML += "<kbd>Number of ranges shown: " + BigInt(ListOfAddress.length).toString(10) + "</kbd><br>"
								//Plaintext
									OutputHTML += "<textarea readonly cols='75' rows='30'>"
									for (let Index = 0; Index < ListOfAddress.length; Index++) {
										OutputHTML += "$" + ListOfAddress[Index][0].toString(16).toUpperCase() + "\t"
										if (document.getElementById("SizeEnding_Size").checked) {
											OutputHTML += ListOfAddress[Index][1].toString(10)
										} else if (document.getElementById("SizeEnding_Ending").checked) {
											OutputHTML += "-$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n).toString(16).toUpperCase()
										} else if (document.getElementById("SizeEnding_Both").checked) {
											OutputHTML += ListOfAddress[Index][1].toString(10) + "/$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n).toString(16).toUpperCase()
										}
										OutputHTML += "\t" + ListOfAddress[Index][2]
										if (document.getElementById("ShowStatusOfData").checked) {
											OutputHTML += " ["
											OutputHTML += "Status: " + ListOfAddress[Index][5] + ", "
											if (ListOfAddress[Index][3].length != 0) {
												OutputHTML += "Overlaps: "
												for (let Index2 = 0; Index2 < ListOfAddress[Index][3].length; Index2++) {
													OutputHTML += ListOfAddress[Index][3][Index2].toString(10)
													if (Index2 != ListOfAddress[Index][3].length -1) {
														OutputHTML += ","
													}
													OutputHTML += " "
												}
												OutputHTML += "| "
											}
											if (ListOfAddress[Index][4] != -1) {
												OutputHTML += "This is AddressTrackerItem_" + BigInt(ListOfAddress[Index][4]).toString(10)
											}
											OutputHTML += "]"
										}
										if (Index != ListOfAddress.length -1)
										OutputHTML += "\n"
									}
									OutputHTML += "</textarea>"
								//HTML table
									OutputHTML += "<table>"
									OutputHTML += "<tr><th>Item number</th><th>Starting address</th><th>Number of bytes(/Ending address)</th><th>Description</th><th>List of item numbers overlaps with</th></tr>"
									for (let Index = 0; Index < ListOfAddress.length; Index++) {
										OutputHTML += "<tr>"
										//Item number
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (ListOfAddress[Index][4] != -1n) {
												OutputHTML += "<kbd>AddressTrackerItem_"+ BigInt(ListOfAddress[Index][4]).toString(10) + "</kbd>"
											} else {
												OutputHTML += "<kbd>Not by user.</kbd>"
											}
											OutputHTML += "</td>"
										//Start address
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											OutputHTML += "<kbd>$" + ListOfAddress[Index][0].toString(16).toUpperCase() + "</kbd>"
											OutputHTML += "</td>"
										//Number of bytes/ending address
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											OutputHTML += "<kbd>" + ListOfAddress[Index][1].toString(10) + "</kbd>"
											if (ListOfAddress[Index][1] > 1n) {
												OutputHTML += "/<kbd>$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] - 1n).toString(16).toUpperCase() + "</kbd>"
											}
											OutputHTML += "</td>"
										//Description
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (document.getElementById("EscapeHTMLTagsAndEscapes").checked) {
												OutputHTML += escapeHTMLChars(ListOfAddress[Index][2])
											} else {
												OutputHTML += ListOfAddress[Index][2]
											}
											OutputHTML += "</td>"
										//Overlaps
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (ListOfAddress[Index][3].length == 0) {
												OutputHTML += ""
											} else {
												OutputHTML += "Conflicts with item number(s) "
												for (let Index2 = 0; Index2 < ListOfAddress[Index][3].length; Index2++) {
													OutputHTML += "<kbd>" + BigInt(ListOfAddress[Index][3][Index2]).toString(10) + "</kbd>"
													if (Index2 != ListOfAddress[Index][3].length -1) {
														OutputHTML += ", "
													}
												}
												OutputHTML += " (Number of stuff it conflicted: " + BigInt(ListOfAddress[Index][3].length).toString(10) + ")"
											}
											OutputHTML += "</td>"
										OutputHTML += "</tr>"
									}
									OutputHTML += "</table>"
						} else if (document.getElementById("ViewMode_ByteByByte").checked) {
							//Byte by byte mode
								//Calculate where the bars will be placed horizontally towards the right when they overlap with another.
									ListOfAddress.sort(SortByStartAddr)
									if (ListOfAddress.length > 1) {
										for (let Index = 0; Index < ListOfAddress.length; Index++) {
											for (let Index2 = Index + 1; Index2 < ListOfAddress.length; Index2++) {
												if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)) {
													while (ListOfAddress[Index][6] == ListOfAddress[Index2][6]) {
														ListOfAddress[Index2][6]++
													}
												}
											}
										}
									}
								//Get only ranges that overlaps the range that is going to be displayed
									let ListOfShownAddress = new Array()
									let FirstRangeBeyondViewProcessed = false //This cuts off the loop once we attempt to process a range beyond the last viewable address on the SVG.
									for (let Index = 0; (Index < ListOfAddress.length && FirstRangeBeyondViewProcessed == false); Index++) {
										if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, StartAddressView, StartAddressView + Setting_ByteView_NumberOfRows)) {
											ListOfShownAddress.push(ListOfAddress[Index])
										}
										if (ListOfAddress[Index][0] > (StartAddressView + Setting_ByteView_NumberOfRows)) {
											FirstRangeBeyondViewProcessed = true
										}
									}
								OutputHTML += "<table><tr><td>"
								OutputHTML += "<svg width='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfColumns).toString(10) + "' height='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfRows).toString(10)+ "'>"
								//Display the column of address and the lines separating each
									for (let Index = 0n; Index < Setting_ByteView_NumberOfRows; Index++) {
										OutputHTML += "<text text-anchor='end' dominant-baseline='hanging' x='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_AddressColumnPosition).toString(10) + "' y='" + (Setting_ByteView_SVGGridSizeFactor*Index).toString(10) + "'>$" + (StartAddressView+Index).toString(16).toUpperCase() + "</text>"
										OutputHTML += "<line stroke='white' x1='0' y1='" + (Setting_ByteView_SVGGridSizeFactor*Index).toString(10) + "' x2='"+(Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfColumns).toString(10)+"' y2='" + (Setting_ByteView_SVGGridSizeFactor*Index).toString(10) + "'></line>"
									}
								//Now display the bars.
									for (let Index = 0; Index < ListOfShownAddress.length; Index++) {
										//Positions cannot be way too far outside the view display as that could result in precision issues, since SVG uses double-precision floating point.
										//The top and left are the origin of the rectangle.
										let BarTopYPos = BigintClamp(ListOfShownAddress[Index][0] - StartAddressView, -1n, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
										let BarBottomYPos = BigintClamp(ListOfShownAddress[Index][0] + ListOfShownAddress[Index][1] - StartAddressView, -1n*Setting_ByteView_SVGGridSizeFactor, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
										let BarHeight = BarBottomYPos - BarTopYPos
										OutputHTML += "<g fill='" + ColorStatus(ListOfShownAddress[Index][5]) + "'>"
										OutputHTML += "<rect x='" + (Setting_ByteView_BarsXPosStart*Setting_ByteView_SVGGridSizeFactor + (ListOfShownAddress[Index][6] * Setting_ByteView_SVGGridSizeFactor)).toString(10) + "' y='" + (BarTopYPos*Setting_ByteView_SVGGridSizeFactor).toString(10) + "' width='" + Setting_ByteView_SVGGridSizeFactor.toString(10) + "' height='" + (BarHeight*Setting_ByteView_SVGGridSizeFactor).toString(10) + "' rx='7' ry='7'>"
										OutputHTML += "<title>$" + ListOfShownAddress[Index][0].toString(16).toUpperCase() + ", " + ListOfShownAddress[Index][1].toString(10) + " byte"
										if (ListOfShownAddress[Index][1] > 1n) {
											OutputHTML += "s (ends at $" + ( ListOfShownAddress[Index][0] + ListOfShownAddress[Index][1] -1n).toString(16).toUpperCase() + "), "
										} else {
											OutputHTML += ", "
										}
										OutputHTML += escapeHTMLChars(ListOfShownAddress[Index][2])
										OutputHTML += "</title>"
										OutputHTML += "</rect>"
										OutputHTML += "</g>"
									}
								OutputHTML += "</svg>"
								OutputHTML += "</td></tr></table>"
						}
				} else {
					OutputHTML += "<kbd>Error: One or more of the lines have invalid number of bytes or ending address.</kbd>"
				}
		} else {
			OutputHTML += "<kbd>Error: One or more of the lines have invalid information.</kbd>"
		}
		document.getElementById("OutputSpanTag").innerHTML = OutputHTML
	}
	//remove duplicate entries
		function RemoveDuplicateAddressEntry(ArrayWithAddresses) {
			//ArrayWithAddresses[Index] contains an array:
			//ArrayWithAddresses[Index][0] = starting address
			//ArrayWithAddresses[Index][1] = number of bytes
			//ArrayWithAddresses[Index][2] = description
			//ArrayWithAddresses[Index][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
			//ArrayWithAddresses[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
			
			//Add a flag mode for each item
				let DuplicateFlagArray = new Array()
				for (let Index = 0; Index < ArrayWithAddresses.length; Index++) {
					DuplicateFlagArray.push([ArrayWithAddresses[Index], false])
				}
				//DuplicateFlagArray[Index][0]: The original array:
				//DuplicateFlagArray[Index][0][0] = starting address
				//DuplicateFlagArray[Index][0][1] = number of bytes
				//DuplicateFlagArray[Index][0][2] = description
				//DuplicateFlagArray[Index][0][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
				//DuplicateFlagArray[Index][0][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
				//DuplicateFlagArray[Index][1]: duplicate flag
			//Now start flagging them
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] != true) {
						for (let Index2 = Index + 1; Index2 < DuplicateFlagArray.length; Index2++) {
							if ((DuplicateFlagArray[Index][0][0] == DuplicateFlagArray[Index2][0][0])&&(DuplicateFlagArray[Index][0][1] == DuplicateFlagArray[Index2][0][1])&&(DuplicateFlagArray[Index][0][2] == DuplicateFlagArray[Index2][0][2])) {
								DuplicateFlagArray[Index2][1] = true
							}
						}
					}
				}
			//Now remove ones flagged dups
				let OutputData = new Array()
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] == false) {
						OutputData.push(DuplicateFlagArray[Index][0])
					}
				}
			return OutputData
		}
//Other subfunctions
	//Remove stuff that is not address data
		function RemoveBlankCommentOrSpacesEntry(InputArray) {
			let OutputArray = new Array()
			let index1 = 0
			let index2 = 0
			while (index1 < InputArray.length) {
				if ((/^(\s*)$|^()$|^(\s*;+.*)$/).test(InputArray[index1]) == false) {
					OutputArray.push(InputArray[index1])
					index2++
				}
				index1++
			}
			return OutputArray
		}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	//Escape
		function escapeHTMLChars(string) {
			//Should the user's input contains "<", ">", and "&", prevent the innerHTML from treating these as HTML tags/escapes
				string = string.replaceAll("&", "&amp;") //This must be done first, to avoid replacing already-replaced symbol's ampersand character.
				string = string.replaceAll("<", "&lt;")
				string = string.replaceAll(">", "&gt;")
				return string
		}
	//Sort functions
		//Start address
			function SortByStartAddr(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? -1 : 1;
				}
			}
			function SortByStartAddrRev(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? 1 : -1;
				}
			}
		//Size
			function SortBySize(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? -1 : 1;
				}
			}
			function SortBySizeRev(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? 1 : -1;
				}
			}
		//Description
			function SortByDescription(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? -1 : 1;
				}
			}
			function SortByDescriptionRev(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? 1 : -1;
				}
			}
		//Status
			function SortByStatus(a, b) {
				if (a[5] === b[5]) {
					return 0;
				} else {
					return (a[5] < b[5]) ? -1 : 1;
				}
			}
			function SortByStatusRev(a, b) {
				if (a[5] === b[5]) {
					return 0;
				} else {
					return (a[5] < b[5]) ? 1 : -1;
				}
			}
		//How many overlaps
			function SortByOverlapCount(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? -1 : 1;
				}
			}
			function SortByOverlapCountRev(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? 1 : -1;
				}
			}
	//Color status
		function ColorStatus(InputString) {
			switch (InputString) {
				case "Gap":
					return "#808080"
				case "NoOverlap":
					return "#008000"
				case "Overlap":
					return "#800000"
				default:
					return "#000080"
			
			}
		}
	//Filter
		function FilterAddress(InputArray) {
			let OutputArray = new Array()
			let FilterList = new Array()
			let ListOfFilters = document.getElementsByClassName("AddressFilter")
			for (let Index = 0; Index < ListOfFilters.length; Index++) {
				if (ListOfFilters[Index].checked) {
					FilterList.push(ListOfFilters[Index].dataset.filter_status)
				}
			}
			for (let Index = 0; Index < InputArray.length; Index++) {
				for (let IndexFilterList = 0; IndexFilterList < FilterList.length; IndexFilterList++) {
					if (InputArray[Index][5] == FilterList[IndexFilterList]) {
						OutputArray.push(InputArray[Index])
					}
				}
			}
			return OutputArray
		}
//Other
	//These makes input text act like a number input, pressing UP/DOWN on the arrow keys to increment/decrement it, but with any radixes.
	//In order for this to apply, have these on the number input:
	//- Make sure the class contains "AnyRadixNumberInput"
	//- Specify what radix it is, have the custom attribute [data-input_number_radix="x"] where x
	//  is a radix number that can be any number 2-36. Examples include: 2 = binary, 10 = decimal (default), 16 = hexadecimal.
	//To get this to apply, use this:
	// window.onload = function(){ //Upon loading, apply the function to execute when the up/down arrow keys are pressed.
	//  UpDownArrowKeysIncrement()
	// }
		function UpDownArrowKeysIncrement() {
			let FocusedElement = document.activeElement;
			if(FocusedElement.addEventListener ) {
				FocusedElement.addEventListener('keydown',this.keyHandler_ArrowKeys,false);
			} else if(FocusedElement.attachEvent ) {
				FocusedElement.attachEvent('onkeydown',this.keyHandler_ArrowKeys);
			}
		}
	
		function keyHandler_ArrowKeys(e) {
			if (((e.code == "ArrowUp")||e.code == "ArrowDown")&&((/(^|\s.*?)AnyRadixNumberInput($|\s.*?)/).test(document.activeElement.className))) {
				let target;
				//Handle radix.
					let Radix = 10
					if ((/^\d+$/).test(document.activeElement.dataset.input_number_radix)) {
						Radix = parseInt(document.activeElement.dataset.input_number_radix)
					}
				let InputNumber = ParseBigIntValue(document.activeElement.value, Radix) //This gets the number
				if (!e) var e = window.event;
				if (e.target) target = e.target;
				else if (e.srcElement) target = e.srcElement;
				
				if(e.code == "ArrowUp") {
					InputNumber++
					e.preventDefault()	//Prevents the caret (blinking text cursor) from being placed at the beginning of the line.
				} else if(e.code == "ArrowDown") {
					InputNumber--
				}
				document.activeElement.value = InputNumber.toString(Radix).toUpperCase()
				document.activeElement.setSelectionRange(document.activeElement.value.length, document.activeElement.value.length)
				document.activeElement.onchange()
			}
		}
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
			return num <= min ? min : num >= max ? max : num;
	}
</script>