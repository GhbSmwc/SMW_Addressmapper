<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			select, option {
				font-family: monospace;
			}
			
			textarea {
				white-space: pre;
				overflow-wrap: normal;
				overflow-x: scroll;
			}
		</style>
	</head>
<body>


<p>This tool will take the provided freeram defines, and the list of unused RAM, and automatically find freeram and will assign each freeram defines to which address to use.</p>

<p>Make sure the supplied RAMs do not overlap.</p>

Format for freeram should be:<br>
<table><tr><td><pre>ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max</pre></td></tr></table>

Where:
<ul>
<li><kbd>ASM_resource_name</kbd> is the name of an ASM resource. Can be any character but must not contain a linebreak or tab.</li>
<li><kbd>!RAM_Define</kbd> is the define name used in the ASM file that represents a RAM to use. Just like above, no linebreaks, no tabs.</li>
<li><kbd>Number_of_bytes_Decimal</kbd> is how many bytes the RAM it requires, in decimal. Must be at least 1.</li>
<li>
	<kbd>Optional_min</kbd>: This is optional, either enter an address hex number (&ldquo;$&rdquo; is optional) or just &ldquo;-&rdquo; to nullify it. When a hex number is supplied, this forces
	the RAM to search for a freeram define to not have its starting address location below this address. This is useful if RAMs that an ASM resource must or must not reset during loading screens (black screen).
</li>
<li><kbd>Optional_max</kbd>: Same as above, but forces the location of a freeram define address not to have its ending byte greater than this address. Note: when both min and max are set, max must be greater than or equal to min.</li>
</ul>
Format for list of empty RAM should be (same as the address tracker):<br>
<table><tr><td><pre>Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description</pre></td></tr></table><br>
All of these ranges must NOT overlap.
<ul>
<li><kbd>Address</kbd> is the starting address. (dollar sign &ldquo;$&rdquo; is optional)</li>
<li><kbd>Size_or_ending_address</kbd> is the size or ending addresses (entering a decimal number results in number of bytes, and typing hyphen &ldquo;-&rdquo;, before a hexadecimal number denotes an ending address (dollar sign &ldquo;$&rdquo; is optional))</li>
<li><kbd>Optional_description</kbd> is optional, will not be checked by this javascript at all. When the remove duplicate flags is checked here, will only check the location and size/ending address.</li>
</ul><br><br>
Notes:
<ul>
	<li>This tool will process each freeram defines from top to bottom order from the text, and the list of gaps at increasing address order. This means that the RAM at the top of the list will be assigned to the lowest address location that it can fit
	(unless if not, will state no suitable address is found)</li>
</ul>

<table>
	<tr>
		<th>Enter your list of ASM resource freeram defines here.</th>
		<th>Enter your list of empty RAMs here.</th>
	</tr>
	<tr>
		<td>
			<textarea id="TextareaInput_FreeramDefines" oninput="RefreshAndMainCode()" cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
		<td>
			<textarea id="TextareaInput_EmptyRams" oninput="RefreshAndMainCode()" cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
	</tr>
</table>
<div>Sort:
<select onchange="MainCode()">
	<option id="SortSetting_None">None</option>
	<option id="SortSetting_ResourceName" selected>Resource name</option>
	<option id="SortSetting_Addr">By address</option>
	<option id="SortSetting_Length">By number of bytes</option>
</select><label><input type="checkbox">Reverse order</label><br><br>
Output format: <select onchange="MainCode()">
	<optgroup label="ASM format">
		<option id="OutputFormatSetting_ASMFormat">ASM define</option>
	</optgroup>
	<optgroup label="Address tracker format">
		<option id="OutputFormatSetting_AddressTracker">Address tracker format - length</option>
		<option id="OutputFormatSetting_AddressTracker">Address tracker format - end address</option>
	</optgroup>
</select><br><br>

Duplicate settings:
	<div><label><input type="checkbox" checked onchange="MainCode()" id="DuplicateSettings_Defines">Ignore duplicates for defines</label></div>
	<div><label><input type="checkbox" checked onchange="MainCode()" id="DuplicateSettings_EmptyRams">Ignore duplicates for gaps</label></div>
</div>
<hr>
<textarea id="TextareaOutput_AssignedRAMs" cols="150" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: #FFFFFF;" readonly></textarea>
<script>
	function keyHandler_Tab(e) {

		let target;
		if (!e) e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				let startPos = target.selectionStart;
				let endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	
	[...document.querySelectorAll("textarea")].forEach(Ele => {
		Ele.addEventListener("keydown", this.keyHandler_Tab, false)
	})
	
	let Saved_Data = {
		FreeramList: [],
		EmptyRamsList: []
	}
	let NeedToUpdateLists = false
	function RefreshAndMainCode() {
		NeedToUpdateLists = true
		MainCode()
	}
	function MainCode() {
		let FreeramList = []
		let ProcessError = false
		document.getElementById("TextareaOutput_AssignedRAMs").value = ""
		let FreeramDefinePlacementCountSuccess = 0
		let FreeramDefinePlacementCountFailed = 0
		
		if (NeedToUpdateLists) {
			let InputText = document.getElementById("TextareaInput_FreeramDefines").value
			InputText = InputText.split("\n")
			FreeramList = InputText.map((Line, Index) => {
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!(/^[^\t]+\t![a-zA-Z\d_]+\t\d+\t(?:-|-?\$?[\dA-Fa-f]+)\t(?:-|-?\$?[\dA-Fa-f]+)/).test(Line)) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Invalid text, please check no mistyped character.",
						LineNumber: Index,
						SourceText: Line
					}
				}
				let PartsOfString = Line.split("\t")
				let ResourceName = PartsOfString[0]
				let DefineName = PartsOfString[1]
				let Length = ParseBigIntValue(PartsOfString[2].replace(/\$/, ""))
				if (Length < 1n) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Number of bytes must be at least 1",
						LineNumber: Index,
						SourceText: Line
					}
				}
				let MinAddress = -Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[3])) {
					MinAddress = ParseBigIntValue(PartsOfString[3].replace(/\$/, ""), 16)
				}
				let MaxAddress = Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[4])) {
					MaxAddress = ParseBigIntValue(PartsOfString[4].replace(/\$/, ""), 16)
				}
				if (MinAddress > MaxAddress) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Max address is before min address.",
						LineNumber: Index,
						SourceText: Line
					}
				}
				return {
					Type: "ValidItem",
					ResourceName: ResourceName,
					DefineName: DefineName,
					Length: Length,
					AssignedAddressStartPos: -Infinity,
					MinAddress: MinAddress,
					MaxAddress: MaxAddress,
					LineNumber: Index,
					SourceText: Line
				}
			})
			if (ProcessError) {
				let ListOfBadFreerams = FreeramList.filter(Item => Item.Type=="Error")
				let ErrorText = "Error! The following items below are invalid free RAM entries:\n"
				ListOfBadFreerams.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				});
				document.getElementById("TextareaOutput_AssignedRAMs").value = ErrorText
				return
			}
			FreeramList = FreeramList.filter(Item => Item.Type=="ValidItem") //Got all our data, 
			if (document.getElementById("DuplicateSettings_Defines").checked) {
				FreeramList = ((ItemsList) => {
					let DupeFree = []
					FreeramList.forEach(Item => {
						let DupedItemOriginal = DupeFree.find(Item2 => {
							if ((Item.ResourceName == Item2.ResourceName)&&(Item.DefineName == Item2.DefineName)&&(Item.Length == Item2.Length)&&(Item.Length == Item2.Length)&&(Item.MinAddress == Item2.MinAddress)&&(Item.MaxAddress == Item2.MaxAddress)) {
								return true
							}
						});
						if (typeof DupedItemOriginal == "undefined") {
							DupeFree.push(Item)
						}
					});
					return DupeFree
				})(FreeramList);
			}
			//FreeramList process are done.
			let ListOfGapsText = document.getElementById("TextareaInput_EmptyRams").value.split('\n')
			let ListOfGaps = ListOfGapsText.map((Line, Index) => {
				let SourceText = Line
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!/^\s*-?\$?[\da-fA-F]+\t(?:\d+|\~-?\$?[\da-fA-F]+)(?:\t.*)?$/.test(Line)) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Line containing invalid information.",
						SourceText: SourceText,
						LineNumber: Index
					}
				
				}
				let LineExtracted = Line.replace(/^\s*/, "").split("\t")
				let StartAddress = ParseBigIntValue(LineExtracted[0].replace("$", ""), 16)
				let EndAddress = 0n
				let Length = 0n
				if (/^\d+$/.test(LineExtracted[1])) { //If Length is provided
					Length = ParseBigIntValue(LineExtracted[1], 10)
					EndAddress = StartAddress+Length-1n
				} else { //Otherwise if ending address provided
					EndAddress = ParseBigIntValue(LineExtracted[1].replace(/^~/, "").replace(/^\$/, ""), 16)
					Length = EndAddress-StartAddress+1n
				}
				if (Length < 1n) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Length less than 1 byte or ending address is less than start address",
						SourceText: SourceText,
						LineNumber: Index
					}
				}
				let Description = LineExtracted[2] ?? ""
				return {
					Type: "Gap",
					SourceText: SourceText,
					LineNumber: Index,
					StartAddress: StartAddress,
					Length: Length,
					EndAddress: EndAddress,
					ConflictsWith: []
				}
			})
			if (ProcessError) {
				let ListOfBadGaps = ListOfGaps.filter(Item => Item.Type=="Error")
				let ErrorText = "Error! The following items below are invalid entries of empty RAMs:\n"
				ListOfBadGaps.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("TextareaOutput_AssignedRAMs").value = ErrorText
				return
			}
			ListOfGaps = ListOfGaps.filter(Item => Item.Type=="Gap")
			if (document.getElementById("DuplicateSettings_EmptyRams").checked) {
				ListOfGaps = ((ItemsList) => { //Remove dupes
					let DupeFree = []
					ListOfGaps.forEach(Item => {
						let DupedItemOriginal = DupeFree.find(Item2 => {
							if ((Item.StartAddress == Item2.StartAddress)&&(Item.Length == Item2.Length)&&(Item.Description == Item2.Description)) {
								return true
							}
						});
						if (typeof DupedItemOriginal == "undefined") {
							DupeFree.push(Item)
						}
					});
					return DupeFree
				})(ListOfGaps);
			}
			//ListOfGaps is done.
			//Check if ListOfGaps contains items that overlap
			{
				let l = ListOfGaps.length
				for (let i=0; i<l; i++) {
					let Item = ListOfGaps[i]
					for (let i2 = i+1; i2<l; i2++) {
						let Item2 = ListOfGaps[i2]
						if (CheckOverlap(Item.StartAddress, Item.EndAddress, Item2.StartAddress, Item2.EndAddress)) {
							Item.Type = "Overlap"
							Item2.Type = "Overlap"
							ProcessError = true
							Item.ConflictsWith.push({
								LineNumber: Item2.LineNumber,
								StartAddress: Item2.StartAddress,
								Length: Item2.Length,
								EndAddress: Item2.EndAddress,
								Description: Item2.Description,
								SourceText: Item2.SourceText,
							})
							Item2.ConflictsWith.push({
								LineNumber: Item.LineNumber,
								StartAddress: Item.StartAddress,
								Length: Item.Length,
								EndAddress: Item.EndAddress,
								Description: Item.Description,
								SourceText: Item.SourceText,
							})
						}
					}
				}
			}
			if (ProcessError) {
				let Overlaps = ListOfGaps.filter(Item => Item.Type=="Overlap")
				let ErrorText = "Error! The following items below are empty RAMs overlapping:\n"
				Overlaps.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]:\n\t;Conflicts with:\n"
					Item.ConflictsWith.forEach((Item2, Index2, Arr2) => {
						ErrorText += "\t;Line " + (Item2.LineNumber+1).toString(10) + " [" + Item2.SourceText + "]"
						if (Index2 != Arr2.length-1) {
							ErrorText += "\n"
						}
					})
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("TextareaOutput_AssignedRAMs").value = ErrorText 
				return
			}
			//Both inputs done. Loop through FreeramList and place them in ListOfGaps
			//Sort, this makes it consistent that bytes will be used from low to high addresses when one define have multiple suitable ranges.
			ListOfGaps.sort((a,b) => Number(a.StartAddress - b.StartAddress))
			//Now place the freeram at a given gap address, and update the gaps list
			let l = FreeramList.length
			let l2 = ListOfGaps.length
			for (let i=0; i<l; i++) { //Loop each freeram define list
				let ASMFreeramDefine = FreeramList[i]
				let IsPlacedUsageSuccessful = false
				let IsAllLaterGapsBeyondMax = false //Cuts off the loop of searching each empty RAMs if we run into the max address (we know that as we go higher up, it still be greater than max.)
				for (let i2 = 0; i2<l2&&(!IsPlacedUsageSuccessful)&&(!IsAllLaterGapsBeyondMax); i2++) { //Loop each RAM gaps
					let GapItem = ListOfGaps[i2]
					//Set up start and end points, accounting for potential min and max addresses
					let StartPos = GapItem.StartAddress
					if (ASMFreeramDefine.MinAddress != -Infinity && StartPos < ASMFreeramDefine.MinAddress) {
						StartPos = ASMFreeramDefine.MinAddress
					}
					let EndPos = GapItem.StartAddress + GapItem.Length-1n
					if (ASMFreeramDefine.MaxAddress != Infinity && EndPos > ASMFreeramDefine.MaxAddress) {
						EndPos = ASMFreeramDefine.MaxAddress
					}
					
					//Get the number of bytes between start and end
					let SizeAvailableSpace = EndPos-StartPos+1n
					if (ASMFreeramDefine.Length <= SizeAvailableSpace) { //If it can fit
						ASMFreeramDefine.AssignedAddressStartPos = StartPos //Freeram have been successfully placed.
						IsPlacedUsageSuccessful = true
						FreeramDefinePlacementCountSuccess++
						
						//modify the empty RAM array. This can potentially split the RAM range into 2 ranges.
						let SplittedRamBeforeStart = {
							StartAddress: GapItem.StartAddress,
							Length: StartPos - GapItem.StartAddress
						}
						
						//find if there will be empty RAM between ASMFreeramDefine.StartingAddress and ASMFreeramDefine.EndingAddress
						//example ASMFreeramDefine 2 bytes used on 7e0060. The GapItem is 4 bytes at 7e0060
						//7e0060 used
						//7e0061 used
						//7e0062 gap
						//7e0063 gap
						let SplittedRamAfterEnd = {
							StartAddress: ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length, //First byte after last used byte.
							Length: GapItem.StartAddress+GapItem.Length - ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length,
						}
						if (SplittedRamBeforeStart.Length < 1n && SplittedRamAfterEnd.Length < 1n) { //Entire range consumed (e.g. all 4 bytes of 7E0060-$7E0063 used up by one define)
							ListOfGaps.splice(i2, 1) //Delete the RAM, it is all used up
						} else if (SplittedRamBeforeStart.Length >= 1n && SplittedRamAfterEnd.Length < 1n) { //Splitted RAM have empty bytes before the used RAM, but up to the end is used
							ListOfGaps.splice(i2, 1, SplittedRamBeforeStart)
						} else if (SplittedRamBeforeStart.Length < 1n && SplittedRamAfterEnd.Length >= 1n) { //Beginning parts of the freeram used up, but leaves a gap between last used byte and last freeram
							ListOfGaps.splice(i2, 1, SplittedRamAfterEnd)
						} else if (SplittedRamBeforeStart.Length >= 1n && SplittedRamAfterEnd.Length >= 1n) { //Split the RAM so both before and after usage there are gaps on either side
							ListOfGaps.splice(i2, 1, SplittedRamBeforeStart, SplittedRamAfterEnd)
						}
						
					} else { //If not, potentially stop the loop entirely and go to next RAM define
						if (ASMFreeramDefine.MaxAddress != Infinity && StartPos+ASMFreeramDefine.Length-1n > ASMFreeramDefine.MaxAddress) {
							//If last byte beyond the max address, it cannot fit and all later empty RAMs are beyond this
							IsAllLaterGapsBeyondMax = true
							FreeramDefinePlacementCountFailed++
						}
					}
				}
			}
			
		}
		//Sorter
		
		//Output
			let OutputString = "Results"
			OutputString += "Success: " + FreeramDefinePlacementCountSuccess.toString(10) + "\n"
			OutputString += "Success: " + FreeramDefinePlacementCountFailed.toString(10) + "\n"
			OutputString += "----------------------------------------------------------------------------------------\n"
			FreeramList.forEach((PlacedRAM, Index, Arr) => {
				if (PlacedRAM.AssignedAddressStartPos != -Infinity) {
					OutputString += PlacedRAM.DefineName + " = " + BigIntToStringSignedHex(PlacedRAM.AssignedAddressStartPos) + ";[" + PlacedRAM.Length + " bytes] " + PlacedRAM.ResourceName
				} else {
					OutputString += PlacedRAM.DefineName + " Error! No suitable RAM found."
				}
				if (Index != Arr.length-1) {
					OutputString += "\n"
				}
			})
			document.getElementById("TextareaOutput_AssignedRAMs").value = OutputString
		
	}
//Helper
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function BigIntToStringSignedHex(BigIntVal) {
		//Converts a bigint value into a signed ASM-styled hex number:
		//16n -> "$10"
		//-16n -> "-$10"
		let StringOutput = ""
		if (BigIntVal >= 0n) {
			StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
		} else {
			StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
		}
		return StringOutput
	}
	function DeleteCopyMessage() {
		CopiedMessage.textContent = ""
	}
</script>