<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
		</style>
	</head>
<body>
	<h1 style="text-align: center;">Address tracker 4.0</h1><br>
	
Enter a list of RAM addresses in the text area below. It must be formatted like this:
<table><tr><td><pre>Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description</pre></td></tr></table><br>
Make sure the format is:
<ul>
	<li>No additional tabs, meaning multiple tabs that are used to align columns in text editors is not allowed. The tab character is reserved for <a href="https://en.wikipedia.org/wiki/Tab-separated_values">tab-separated values</a>.</li>
</ul>

Notes:
	<ul>
		<li>Lines that are blank or composed of just any whitespace characters are ignored. It will also ignore any lines that start with either a semicolon or a space (0 or more), followed by a semicolon (therefore ASM-styled comments are allowed).</li>
		<li>Whitespace shown above is a TAB character, not a literal space character.</li>
		<li>This does not take in account of addressing mirroring (a shorthand <kbd>$00</kbd> instead of <kbd>$7E0000</kbd>), so I strongly recommend putting the full address numbers here. Furthermore, it does not detect what type of memory map it is,
		things like negative address (only shown on &ldquo;<kbd>Potential ending address before the starting byte of all the ranges</kbd>&rdquo;), address pointing beyond the last byte of the entire memory map, and so on.</li>
		<li>This tool could be applied to other systems (beyond the SNES), since it merely check ranges.</li>
	</ul>

Where:
<ul>
	<li><kbd>Address</kbd> is the starting address, in hex. <kbd>$</kbd> prefix is optional.</li>
	<li><kbd>Size_in_bytes_Or_EndAddress</kbd> can either be the number of bytes starting from <kbd>Address</kbd> and ending at <kbd>Address + Size_in_bytes - 1</kbd> or the ending address:
		<ul>
			<li><kbd>Decimal_Number</kbd> - number of bytes, in decimal. Don't use commas to separate digit grouping.</li>
			<li><kbd>-Hexidecimal_EndAddress</kbd> - the ending address (note the hyphen to denote a range), in hex. Also <kbd>$</kbd> prefix is optional (must be placed after
			the hyphen and before the hexadecimal address number (example: <kbd>$-10</kbd> is wrong, <kbd>-$10</kbd> is correct)).</li>
		</ul>
	</li>
	<li><kbd>Description</kbd> (optional) is a brief description. Note: HTML tags, elements and other reserved symbols apply on the description, and improper opening and closing/ending tags could <abbr title="For example: having only the opening tag or closing/ending tag, if you end the table tag (/td/tr/table), before you start it (tabletrtd), it would mess up the outer table's content after the invalid HTML setup.">break the table</abbr>!
	If you want to view the table with invalid tag setup and have it not be broken, check the box labeled &ldquo;Escape html tags and escape characters for table description&rdquo;, and it will cancel out the HTML effects (they're <a href="https://en.wikipedia.org/wiki/Character_encodings_in_HTML#XML_character_references">escaped</a>) within the description field.</li>
</ul>
If there are re-used addresses on multiple entries, they will display as a row colored red with the text &ldquo;Overlap detected!&rdquo; written next to their starting address being affected. If there are gaps between two closest ranges, will insert
a grey entry stating a gap.<br><br>

<textarea id="UserInputList" cols="75" rows="30" oninput="MainCode()"></textarea><br><br>
<table>
<tr>
<th><label><input type="radio" name="ViewMode" id="ViewMode_TableRangeMode" onchange="MainCode()" checked>Table range view</label></th>
<th><label><input type="radio" name="ViewMode" id="ViewMode_ByteByByte" onchange="MainCode()">Byte by byte address view</label></th>
</tr>
<tr>
<td>
<label><input type="checkbox" checked id="CleanDuplicateEntries" onchange="MainCode()"><abbr title="Any lines that are identical copies are ignored and not flagged as an overlap.">Ignore duplicates</abbr></label><br>
<label><input type="checkbox" id="EscapeHTMLTagsAndEscapes" onchange="MainCode()">Escape html tags and escape characters for table description (this prevents potential invalid opening/closing HTML tags from breaking the table).</label><br><br>

Sort by:<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_None">Keep order you sent</label><br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_StartAddress" checked>Starting address</label> (<label><input type="radio" name="Sorter" id="Sort_StartAddress_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Size">Size</label> (<label><input type="radio" name="Sorter" id="Sort_Size_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Description">Description</label> (<label><input type="radio" name="Sorter" id="Sort_Description_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Type">Gap/No overlap/Overlap</label> (<label><input type="radio" name="Sorter" id="Sort_Type_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_HowManyOverlaps">How many overlaps</label> (<label><input type="radio" name="Sorter" id="Sort_HowManyOverlaps_Reverse" onchange="MainCode()">reverse</label>)<br><br>

Filter: <button onclick="CheckAllFilters(); MainCode()">Check All</button><button onclick="UncheckAllFilters(); MainCode()">Uncheck All</button><button onclick="InvertAllFilters(); MainCode()">Invert</button><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="Gap" checked>Unused gaps</label><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="NoOverlap" checked>Used addresses that didn't overlap</label><br>
<label><input type="checkbox" onchange="MainCode()" class="AddressFilter" data-filter_status="Overlap" checked>Addresses that overlap</label><br><br>

Plantext size/ending address mode display:<br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Size"checked>Size</label><br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Ending">Ending</label><br>
<label><input type="radio" name="SizeEndingAddress" onchange="MainCode()" id="SizeEnding_Both">Size and ending (<kbd>&lt;size&gt;/-&lt;ending_address&gt;</kbd>)</label><br>
<label><input type="checkbox" onchange="MainCode()" id="ShowStatusOfData">Show status of ram usage (gap, overlap, and no-overlaps)</label>
</td>
<td>
Address to view: $<input type="text" class="AnyRadixNumberInput" data-input_number_radix="16" id="ByteByByteViewStartingAddress" onchange="MainCode()" value="7E0000"><br><br>

Useful tips using this feature:
<ul>
<li>Hover your mouse over the display and roll your scroll wheel to scroll the range</li>
<li>To scroll by an entire screen, hold SHIFT and roll your scroll wheel.</li>
<li>You can also scroll the display by holding SHIFT and hold down left-click and then move the mouse up or down.</li>
</ul>
</td>
</tr>
</table>
<hr>
<br><br>

<span id="OutputSpanTag" class="HideableOutputElements"></span>
<span id="HTML_Output_Statistics" hidden class="HideableOutputElements"></span>
<textarea id="HTML_Output_PlainTextOfUsedRanges" hidden readonly cols='75' rows='30' class="HideableOutputElements"></textarea>
<table id="HTML_Output_TableOfUsedRanges" hidden class="HideableOutputElements"></table>
<span id="ViewMode_Error" hidden class="HideableOutputElements">
	<textarea id="HTML_Output_Error" cols='75' rows='30'></textarea>
</span>
<span id="ViewMode_ByteByByteGraph" hidden class="HideableOutputElements">
	<table>
	<tr><th>Viewing <span id="ViewMode_ByteByByteGraph_ViewingRange"></th></tr>
	<tr>
		<td><span id="HTML_Output_SVGGraph"></span>
			<span id="SVG_VectorGraph"></span>
		</td>
	</tr>
	</table>
</span>
<script>
//Settings (akin to defines settings)
	const Setting_ByteView_SVGGridSizeFactor = 16n
	const Setting_ByteView_AddressColumnPosition = 5n		//Note: right-aligned, from text-anchor, position of the right edge of text
	const Setting_ByteView_BarsXPosStart = 5n			//Note: left-aligned, position from left edge.
	const Setting_ByteView_NumberOfRows = 100n
	const Setting_ByteView_NumberOfColumns = 20n			//Width of viewbox, that, multiplied by Setting_ByteView_SVGGridSizeFactor
//Various variables used for dragmode
	var DragMode_State = false
	var MouseDragOriginX = 0
	var MouseDragOriginY = 0
	var CurrentNumberInputValueSelected //This prevents the input from adding by itself and accumulating. Done by saving its original value, and add by delta
//Tab key & other event listener stuff
//Tab key to make it not switch the focus and actually insert a tab character.
//Also adds a onclick for drag to move the visual display
	window.onload = function(){    
		UpDownArrowKeysIncrement()	//Arrow keys
		var addressList = document.getElementById("UserInputList"); //Tab handler to insert tab character
		if(addressList.addEventListener ) {
			addressList.addEventListener('keydown',this.keyHandler_Tab,false);
		} else if(addressList.attachEvent ) {
			addressList.attachEvent('onkeydown',this.keyHandler_Tab);
		}
		//Mouse dragging function for visual display graph.
			//Pressing down (start of drag mode)
				document.getElementById("ViewMode_ByteByByteGraph").addEventListener('mousedown', Set_DragMode_On)
			//Mouse moves (after pressing down on the button)
				document.addEventListener('mousemove', DragMode_MoveSVGGraph)
			//Mouse dragging
				document.addEventListener('mouseup', Set_DragMode_Off)
	}

	function keyHandler_Tab(e) {

		var target;
		if (!e) var e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				var startPos = target.selectionStart;
				var endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
//Add mouse-drag-scroll feature to the visual display
	function Set_DragMode_On(e) {
		if (e.shiftKey&&e.button == 0) {
			e.preventDefault()
			DragMode_State = true
			MouseDragOriginX = e.clientX
			MouseDragOriginY = e.clientY
			CurrentNumberInputValueSelected = ParseBigIntValue(document.getElementById("ByteByByteViewStartingAddress").value, 16)
		}
	}
	function Set_DragMode_Off() {
		DragMode_State = false
		MouseDragOriginX = 0
		MouseDragOriginY = 0
	}
	function DragMode_MoveSVGGraph() {
	
	}
	function DragMode_MoveSVGGraph(e) { //Drag-scrolling
		if (DragMode_State&&e.shiftKey) {
			let MouseDeltaX = e.clientX - MouseDragOriginX
			let MouseDeltaY = e.clientY - MouseDragOriginY
			
			let DeltaValueToAdjustAddress = BigInt(MouseDeltaY)
			let StartAddressView = ParseBigIntValue(document.getElementById("ByteByByteViewStartingAddress").value, 16)
			document.getElementById("ByteByByteViewStartingAddress").value = (CurrentNumberInputValueSelected + (DeltaValueToAdjustAddress*-1n)/Setting_ByteView_SVGGridSizeFactor).toString(16).toUpperCase()
			MainCode()
		} else {
			Set_DragMode_Off() //The next time the user moves the mouse with the shift not being held down will exit out of drag-scrolling
		}
	}
//Filter checkbox functions
	function CheckAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = 1
		}
	}
	function UncheckAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = 0
		}
	}
	function InvertAllFilters() {
		let ListOfFilters = document.getElementsByClassName("AddressFilter")
		for (let Index = 0; Index < ListOfFilters.length; Index++) {
			ListOfFilters[Index].checked = ListOfFilters[Index].checked ^ 1
		}
	}
//Regex stuff
	String2Regex_CorrectLine = "^\\$?[0-9A-Fa-f]+\\t(\\d+|-\\$?[0-9A-Fa-f]+)(\\t[^\\t]*?)?$"
	String2Regex_GetStartingAddress = "(?<=^\\$?)[0-9A-Fa-f]+"
	String2Regex_GetNumberOfBytesOrEndingAddress = "(?<=^\\$?[0-9A-Fa-f]+\\t)(\\d+|-\\$?[0-9A-Fa-f]+)"
	String2Regex_GetDiscription = "(?<=^[^\\t]+\\t[^\\t]+\\t)[^\\t]+$"
//Main functions
	function MainCode() {
	//Start with everything empty first
		{
			let ItemsWithHiddenSetting = document.getElementsByClassName("HideableOutputElements")
			for (let Index = 0; Index < ItemsWithHiddenSetting.length; Index++) {
				ItemsWithHiddenSetting[Index].hidden = true
			}
		}
		let ListOfAddress = new Array()
	//Some input data
		let StartAddressView = ParseBigIntValue(document.getElementById("ByteByByteViewStartingAddress").value, 16)
		if (StartAddressView < 0n) {
			StartAddressView = 0n
		}
		document.getElementById("ByteByByteViewStartingAddress").value = StartAddressView.toString(16).toUpperCase()
	//Get each line of text.
		//let UserInputList = RemoveBlankCommentOrSpacesEntry(document.getElementById("UserInputList").value.split('\n'))
		let UserInputList = new Array()
		for (let Index = 0 ; Index < document.getElementById("UserInputList").value.split('\n').length; Index++) {
			UserInputList.push([document.getElementById("UserInputList").value.split('\n')[Index], Index])
		}
	//Remove lines that are just useless (just blanks, spaces, comments)
		UserInputList = RemoveBlankCommentOrSpacesEntry(UserInputList)
		//UserInputList[Index][0] = the line of a text
		//UserInputList[Index][1] = the page number, minus 1.
	//Check if all lines are correct.
		let IsAllStringsValid = true
		for (let Index = 0; (Index < UserInputList.length&&IsAllStringsValid == true); Index++) {
			if (!(RegExp(String2Regex_CorrectLine).test(UserInputList[Index][0]))) {
				IsAllStringsValid = false
			}
		}
		if (IsAllStringsValid) {
			//Verify that the number of bytes/ending address are correct.
			//Number of bytes should be at least 1, and ending address not to be less than the starting address.
			//Easy way is to have them all be number of bytes.
			
			//However, we need to convert the first two columns, the address and the number of bytes or ending address
			//first.
				for (let Index = 0; Index < UserInputList.length; Index++) {
					let StartAddress = BigInt("0x" + UserInputList[Index][0].match(RegExp(String2Regex_GetStartingAddress))[0])
					let NumbOfBytesOrEndAddress_String = UserInputList[Index][0].match(RegExp(String2Regex_GetNumberOfBytesOrEndingAddress))[0]
					let NumberOfBytes = 0n
					if ((/^\d+$/).test(NumbOfBytesOrEndAddress_String)) {
						NumberOfBytes = BigInt(NumbOfBytesOrEndAddress_String)
					} else {
						let EndingAddressString = NumbOfBytesOrEndAddress_String.replace(/-\$?/, "")
						NumberOfBytes = BigInt("0x" + EndingAddressString) - StartAddress + 1n
					}
					let Description = ""
					if ((RegExp(String2Regex_GetDiscription)).test(UserInputList[Index][0])) {
						Description += UserInputList[Index][0].match(RegExp(String2Regex_GetDiscription))[0]
					}
					ListOfAddress.push([StartAddress, NumberOfBytes, Description, [], -1, "NoOverlap", 0n, UserInputList[Index][1]])
				}
			//ListOfAddress[Index] now contains an array:
			//ListOfAddress[Index][0] = starting address
			//ListOfAddress[Index][1] = number of bytes
			//ListOfAddress[Index][2] = description
			//ListOfAddress[Index][3] = sub-array containing other items in ListOfAddress that overlaps this
			//ListOfAddress[Index][3][Index2][0] = starting address of an item it conflict
			//ListOfAddress[Index][3][Index2][1] = size of an item it conflict
			//ListOfAddress[Index][3][Index2][2] = description of an item it conflict
			//ListOfAddress[Index][3][Index2][3] = item number of an item it conflict
			//ListOfAddress[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0. If -1n, then it's generated by this JS for gaps.
			//ListOfAddress[Index][5] = Status/type ("NoOverlap", "Overlap" "Gap")
			//ListOfAddress[Index][6] = Horizontal position for SVG bar placement.
			//ListOfAddress[Index][7] = line number, minus 1. Used in case of invalid lines or wrong number of bytes/ending address lower than the start address.
			//Let's check if any had wrong number of bytes or ending address
				let IsNumberOfBytesCorrectOnAll = true
				for (let Index = 0; (Index < ListOfAddress.length&& IsNumberOfBytesCorrectOnAll == true); Index++) {
					if (ListOfAddress[Index][1] < 1n) {
						IsNumberOfBytesCorrectOnAll = false
					}
				}
			//If all number of bytes are valid
				if (IsNumberOfBytesCorrectOnAll) {
					//Clean duplicates
						if (document.getElementById("CleanDuplicateEntries").checked) {
							ListOfAddress = RemoveDuplicateAddressEntry(ListOfAddress)
						}
					//Number the items (excluding duplicates when that checkbox is checked)
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							ListOfAddress[Index][4] = Index
						}
					//Check if any address overlaps another
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							for (let Index2 = Index + 1; Index2 < ListOfAddress.length; Index2++) {
								if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)) {
									//Write each other's overlap list
										ListOfAddress[Index][3].push([ListOfAddress[Index2][0], ListOfAddress[Index2][1], ListOfAddress[Index2][2], ListOfAddress[Index2][4]])
										ListOfAddress[Index2][3].push([ListOfAddress[Index][0], ListOfAddress[Index][1], ListOfAddress[Index][2], ListOfAddress[Index][4]])
									//Mark they're overlapping
										ListOfAddress[Index][5] = "Overlap"
										ListOfAddress[Index2][5] = "Overlap"
								}
							}
						}
					//Get list of gaps
						let Count_Gap = 0
							{
								//let ArrayCopyButSortedForGapFinding = ListOfAddress.sort(SortByStartAddr) <-This will sort BOTH arrays.
								// Needed in case if we have multiple overlapping address. When having multiple overlapping addresses, the ending address
								// of the last range processed is NOT always the last byte, if we had (1st) one address, and then another (2nd) but shorter range,
								// we wouldn't want to use the ending address of 2nd because we look at the address after the last byte of whoever is the longest.
								// Made up example:
								//  7E0060-7E0063	;>First
								//  7E0061-7E0062	;>Second
								// 7E0063 is what we assume the last byte, not 7E0062. Essentially, HighestEndAddressGapDetect holds the highest ending address
								// currently processed that overlaps.
									let HighestEndAddressGapDetect = -1n
									let GapAddressList = new Array()
									let ArrayCopyButSortedForGapFinding = [...ListOfAddress] //thanks to https://www.samanthaming.com/tidbits/35-es6-way-to-clone-an-array/ for telling me that the assignment operator "=" doesn't actually copy the array.
									ArrayCopyButSortedForGapFinding.sort(SortByStartAddr)
									for (let Index = 1; Index < ArrayCopyButSortedForGapFinding.length; Index++) {
										//If the highest index exceeds HighestEndAddressGapDetect, replace it with the higher number
											if (ArrayCopyButSortedForGapFinding[Index - 1][0] + ArrayCopyButSortedForGapFinding[Index - 1][1] - 1n > HighestEndAddressGapDetect) {
												HighestEndAddressGapDetect = ArrayCopyButSortedForGapFinding[Index - 1][0] + ArrayCopyButSortedForGapFinding[Index - 1][1] - 1n
											}
											if (ArrayCopyButSortedForGapFinding[Index][0] > HighestEndAddressGapDetect + 1n) {
												//Create an array containing between-range gap addresses.
													GapAddressList.push([(HighestEndAddressGapDetect + 1n), (ArrayCopyButSortedForGapFinding[Index][0] - HighestEndAddressGapDetect - 1n), "Gap", [], -1, "Gap", 0n])
													//ListOfGaps.push(GapArray)
											}
											
									}
									for (let Index = 0; Index < GapAddressList.length; Index++) {
										ListOfAddress.push(GapAddressList[Index])
									}
									Count_Gap = GapAddressList.length
							}
					//Statistics
						let Count_TotalNumberOfRanges_PriorFilter = ListOfAddress.length
						let Count_Overlap = 0
						let Count_NoOverlap = 0
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							if (ListOfAddress[Index][5] == "Overlap") {
								Count_Overlap++
							}
							if (ListOfAddress[Index][5] == "NoOverlap") {
								Count_NoOverlap++
							}
						}
						let OutputHTML = ""
						if (document.getElementById("ViewMode_TableRangeMode").checked) {
							//Filter
								ListOfAddress = FilterAddress(ListOfAddress)
							//Sort it
								if (document.getElementById("Sort_StartAddress").checked) {
									ListOfAddress.sort(SortByStartAddr)
								} else if (document.getElementById("Sort_StartAddress_Reverse").checked) {
									ListOfAddress.sort(SortByStartAddrRev)
								} else if (document.getElementById("Sort_Size").checked) {
									ListOfAddress.sort(SortBySize)
								} else if (document.getElementById("Sort_Size_Reverse").checked) {
									ListOfAddress.sort(SortBySizeRev)
								} else if (document.getElementById("Sort_Description").checked) {
									ListOfAddress.sort(SortByDescription)
								} else if (document.getElementById("Sort_Type").checked) {
									ListOfAddress.sort(SortByStatus)
								} else if (document.getElementById("Sort_Type_Reverse").checked) {
									ListOfAddress.sort(SortByStatusRev)
								} else if (document.getElementById("Sort_Description_Reverse").checked) {
									ListOfAddress.sort(SortByDescriptionRev)
								} else if (document.getElementById("Sort_HowManyOverlaps").checked) {
									ListOfAddress.sort(SortByOverlapCount)
								} else if (document.getElementById("Sort_HowManyOverlaps_Reverse").checked) {
									ListOfAddress.sort(SortByOverlapCountRev)
								}
							//Now display it
								//Statistics
									OutputHTML += "<ul>"
									OutputHTML += "<li><kbd>Total number of ranges found (including gaps): " + BigInt(Count_TotalNumberOfRanges_PriorFilter).toString(10) + "</kbd></li>"
									OutputHTML += "<ul>"
									OutputHTML += "<li><kbd style='color: #00FF00'>Number of used RAM ranges not overlapping: " + BigInt(Count_NoOverlap).toString(10) + "</kbd></li>"
									OutputHTML += "<li><kbd style='color: #FF0000'>Number of used RAM ranges overlapping: " + BigInt(Count_Overlap).toString(10) + "</kbd></li>"
									OutputHTML += "<li><kbd style='color: #808080'>Number of gaps: " + BigInt(Count_Gap).toString(10) + "</kbd></li>"
									OutputHTML += "</ul>"
									OutputHTML += "</ul><br><br>"
									//how many shown
										OutputHTML += "<kbd>Number of ranges shown: " + BigInt(ListOfAddress.length).toString(10) + "</kbd><br>"
									//Display the statistics
										document.getElementById("HTML_Output_Statistics").hidden = false
										document.getElementById("HTML_Output_Statistics").innerHTML = OutputHTML
								//Plaintext
									OutputHTML = ""
									for (let Index = 0; Index < ListOfAddress.length; Index++) {
										OutputHTML += "$" + ListOfAddress[Index][0].toString(16).toUpperCase() + "\t"
										if (document.getElementById("SizeEnding_Size").checked) {
											OutputHTML += ListOfAddress[Index][1].toString(10)
										} else if (document.getElementById("SizeEnding_Ending").checked) {
											OutputHTML += "-$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n).toString(16).toUpperCase()
										} else if (document.getElementById("SizeEnding_Both").checked) {
											OutputHTML += ListOfAddress[Index][1].toString(10) + "/$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n).toString(16).toUpperCase()
										}
										OutputHTML += "\t" + ListOfAddress[Index][2]
										if (document.getElementById("ShowStatusOfData").checked) {
											OutputHTML += " ["
											OutputHTML += "Status: " + ListOfAddress[Index][5] + ", "
											if (ListOfAddress[Index][3].length != 0) {
												OutputHTML += "Overlaps: "
												for (let Index2 = 0; Index2 < ListOfAddress[Index][3].length; Index2++) {
													OutputHTML += ListOfAddress[Index][3][Index2][3].toString(10)
													if (Index2 != ListOfAddress[Index][3].length -1) {
														OutputHTML += ","
													}
													OutputHTML += " "
												}
												OutputHTML += "| "
											}
											if (ListOfAddress[Index][4] != -1) {
												OutputHTML += "This is AddressTrackerItem_" + BigInt(ListOfAddress[Index][4]).toString(10)
											}
											OutputHTML += "]"
										}
										if (Index != ListOfAddress.length -1) {
											OutputHTML += "\n"
										}
									}
									document.getElementById("HTML_Output_PlainTextOfUsedRanges").hidden = false
									document.getElementById("HTML_Output_PlainTextOfUsedRanges").value = OutputHTML
								//HTML table
									OutputHTML = ""
									OutputHTML += "<tr><th>Item number</th><th>Starting address</th><th>Number of bytes(/Ending address)</th><th>Description</th><th>Overlaps with</th></tr>"
									for (let Index = 0; Index < ListOfAddress.length; Index++) {
										OutputHTML += "<tr>"
										//Item number
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (ListOfAddress[Index][4] != -1n) {
												OutputHTML += "<kbd>AddressTrackerItem_"+ BigInt(ListOfAddress[Index][4]).toString(10) + "</kbd>"
											} else {
												OutputHTML += "<kbd>Not by user.</kbd>"
											}
											OutputHTML += "</td>"
										//Start address
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											OutputHTML += "<kbd>$" + ListOfAddress[Index][0].toString(16).toUpperCase() + "</kbd>"
											OutputHTML += "</td>"
										//Number of bytes/ending address
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											OutputHTML += "<kbd>" + ListOfAddress[Index][1].toString(10) + "</kbd>"
											if (ListOfAddress[Index][1] > 1n) {
												OutputHTML += "/<kbd>$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] - 1n).toString(16).toUpperCase() + "</kbd>"
											}
											OutputHTML += "</td>"
										//Description
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (document.getElementById("EscapeHTMLTagsAndEscapes").checked) {
												OutputHTML += escapeHTMLChars(ListOfAddress[Index][2])
											} else {
												OutputHTML += ListOfAddress[Index][2]
											}
											OutputHTML += "</td>"
										//Overlaps
											OutputHTML += "<td style='background-color: " + ColorStatus(ListOfAddress[Index][5]) + "'>"
											if (ListOfAddress[Index][3].length == 0) {
												if (ListOfAddress[Index][5] != "Gap")
												OutputHTML += "No Overlaps"
											} else {
												//ListOfAddress[Index] now contains an array:
												//ListOfAddress[Index][0] = starting address
												//ListOfAddress[Index][1] = number of bytes
												//ListOfAddress[Index][2] = description
												//ListOfAddress[Index][3] = sub-array containing other items in ListOfAddress that overlaps this
												//ListOfAddress[Index][3][Index2][0] = starting address of an item it conflict
												//ListOfAddress[Index][3][Index2][1] = size of an item it conflict
												//ListOfAddress[Index][3][Index2][2] = description of an item it conflict
												//ListOfAddress[Index][3][Index2][3] = item number of an item it conflict
												//ListOfAddress[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0. If -1n, then it's generated by this JS for gaps.
												//ListOfAddress[Index][5] = Status/type ("NoOverlap", "Overlap" "Gap")
												//ListOfAddress[Index][6] = Horizontal position for SVG bar placement.
												//ListOfAddress[Index][7] = line number, minus 1. Used in case of invalid lines or wrong number of bytes/ending address lower than the start address.
												//Let's check if any had wrong number of bytes or ending address
												OutputHTML += "Conflicts with:<br><br>"
												OutputHTML += "<table>"
												OutputHTML += "<tr><th>Item number</th><th>Starting address</th><th>Number of bytes(/Ending address)</th><th>Description</th></tr>"
												for (let Index2 = 0; Index2 < ListOfAddress[Index][3].length; Index2++) {
													OutputHTML += "<tr>"
													//Item number
														OutputHTML += "<td><kbd>AddressTrackerItem_" + ListOfAddress[Index][3][Index2][3].toString(10) + "</kbd></td>"
													//Address
														OutputHTML += "<td><kbd>$" + ListOfAddress[Index][3][Index2][0].toString(16).toUpperCase() + "</kbd></td>"
													//size/ending address
														OutputHTML += "<td><kbd>" + ListOfAddress[Index][3][Index2][1].toString(10) + "</kbd>/<kbd>$" + (ListOfAddress[Index][3][Index2][0] + ListOfAddress[Index][3][Index2][1] -1n).toString(16).toUpperCase() + "</kbd></td>"
													//Description
														OutputHTML += "<td>" + ListOfAddress[Index][3][Index2][2] + "</td>"
													OutputHTML += "</tr>"
												}
												OutputHTML += "</table><br>"
												OutputHTML += " (Number of stuff it conflicted: " + BigInt(ListOfAddress[Index][3].length).toString(10) + ")"
											}
											OutputHTML += "</td>"
										OutputHTML += "</tr>"
									}
									document.getElementById("HTML_Output_TableOfUsedRanges").hidden = false
									document.getElementById("HTML_Output_TableOfUsedRanges").innerHTML = OutputHTML
						} else if (document.getElementById("ViewMode_ByteByByte").checked) {
							//Byte by byte mode (SVG graph)
								//Easier if this is sorted, since the visual display is in increasing order.
									ListOfAddress.sort(SortByStartAddr)
								//Calculate where the bars will be placed horizontally towards the right when they overlap with another.
								//(CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)&& ListOfAddress[Index][6] == ListOfAddress[Index2][6]) will check
								//ListOfAddress[Index][6]++ means shift to the right
									if (ListOfAddress.length > 1) {
										for (let Index = 1; Index < ListOfAddress.length; Index++) {
											let IsOverlappingXY = false
											do {
												IsOverlappingXY = false
												for (let Index2 = 0; (Index2 < Index&&IsOverlappingXY == false); Index2++) {
													if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)&& ListOfAddress[Index][6] == ListOfAddress[Index2][6]) {
														IsOverlappingXY = true
													}
												}
												if (IsOverlappingXY) {
													ListOfAddress[Index][6]++
												}
											} while (IsOverlappingXY)
										}
									}
								//Get only ranges that overlaps the range that is going to be displayed
									let ListOfShownAddress = new Array()
									let FirstRangeBeyondViewProcessed = false //This cuts off the loop once we attempt to process a range beyond the last viewable address on the SVG.
									for (let Index = 0; (Index < ListOfAddress.length && FirstRangeBeyondViewProcessed == false); Index++) {
										if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, StartAddressView, StartAddressView + Setting_ByteView_NumberOfRows)) {
											ListOfShownAddress.push(ListOfAddress[Index])
										}
										if (ListOfAddress[Index][0] > (StartAddressView + Setting_ByteView_NumberOfRows)) {
											FirstRangeBeyondViewProcessed = true
										}
									}
									document.getElementById("ViewMode_ByteByByteGraph_ViewingRange").innerHTML = "$" + StartAddressView.toString(16).toUpperCase() + "-$" + (StartAddressView+Setting_ByteView_NumberOfRows-1n).toString(16).toUpperCase()
								//Display
									OutputHTML += "<svg id='ScrollableSVG' width='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfColumns).toString(10) + "' height='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfRows).toString(10)+ "'>"
									for (let Index = 0n; Index < Setting_ByteView_NumberOfRows; Index++) {
										OutputHTML += "<text text-anchor='end' dominant-baseline='middle' x='" + (Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_AddressColumnPosition).toString(10) + "' y='" + (Setting_ByteView_SVGGridSizeFactor*Index + Setting_ByteView_SVGGridSizeFactor/2n).toString(10) + "'>$" + (StartAddressView+Index).toString(16).toUpperCase() + "</text>"
										OutputHTML += "<line stroke='white' x1='0' y1='" + (Setting_ByteView_SVGGridSizeFactor*Index).toString(10) + "' x2='"+(Setting_ByteView_SVGGridSizeFactor*Setting_ByteView_NumberOfColumns).toString(10)+"' y2='" + (Setting_ByteView_SVGGridSizeFactor*Index).toString(10) + "'></line>"
									}
									for (let Index = 0; Index < ListOfShownAddress.length; Index++) {
										//Positions cannot be way too far outside the view display as that could result in precision issues, since SVG uses double-precision floating point.
										//They are clamped between -1 and Setting_ByteView_NumberOfRows+1 (1 row OUTSIDE the display) instead of 0 to Setting_ByteView_NumberOfRows so that
										//if either endpoints happens to be outside the view display, the rounded corners would not be misleadingly be displayed at the top and bottom of
										//the display, which avoids giving the user the impression their start and end position would be there when they actually extend beyond it.
										//The top and left are the origin of the rectangle, which is why it is calculated using BottomPos - TopPos.
										let BarTopYPos = BigintClamp(ListOfShownAddress[Index][0] - StartAddressView, -1n, Setting_ByteView_NumberOfRows+1n)
										let BarBottomYPos = BigintClamp(ListOfShownAddress[Index][0] + ListOfShownAddress[Index][1] - StartAddressView, -1n*Setting_ByteView_SVGGridSizeFactor, Setting_ByteView_NumberOfRows+1n)
										let BarHeight = BarBottomYPos - BarTopYPos
										OutputHTML += "<g fill='" + ColorStatus(ListOfShownAddress[Index][5]) + "'>"
										OutputHTML += "<rect x='" + (Setting_ByteView_BarsXPosStart*Setting_ByteView_SVGGridSizeFactor + (ListOfShownAddress[Index][6] * Setting_ByteView_SVGGridSizeFactor)).toString(10) + "' y='" + (BarTopYPos*Setting_ByteView_SVGGridSizeFactor).toString(10) + "' width='" + Setting_ByteView_SVGGridSizeFactor.toString(10) + "' height='" + (BarHeight*Setting_ByteView_SVGGridSizeFactor).toString(10) + "' rx='7' ry='7'>"
										OutputHTML += "<title>$" + ListOfShownAddress[Index][0].toString(16).toUpperCase() + ", " + ListOfShownAddress[Index][1].toString(10) + " byte"
										if (ListOfShownAddress[Index][1] > 1n) {
											OutputHTML += "s (ends at $" + ( ListOfShownAddress[Index][0] + ListOfShownAddress[Index][1] -1n).toString(16).toUpperCase() + "), "
										} else {
											OutputHTML += ", "
										}
										OutputHTML += escapeHTMLChars(ListOfShownAddress[Index][2])
										OutputHTML += "</title>"
										OutputHTML += "</rect>"
										OutputHTML += "</g>"
									}
									OutputHTML += "</svg>"
									document.getElementById("ViewMode_ByteByByteGraph").hidden = false
									document.getElementById("SVG_VectorGraph").innerHTML = OutputHTML
						}
				} else {
					OutputHTML = ""
					let ListOfWrongByteSize = new Array()
					for (let Index = 0; Index < ListOfAddress.length; Index++) {
						if (ListOfAddress[Index][1] < 1n) {
							ListOfWrongByteSize.push(ListOfAddress[Index])
						}
					}
					OutputHTML += "Error: These addresses contain the wrong number of bytes and/or ending addresses being lower than the starting addresses:\n"
					for (let Index = 0; Index < ListOfWrongByteSize.length; Index++) {
						OutputHTML += "Line " + BigInt(ListOfWrongByteSize[Index][7] + 1).toString(10) + ": Address $" + BigInt(ListOfWrongByteSize[Index][0]).toString(16).toUpperCase() + ", Description: " + ListOfWrongByteSize[Index][2]
						if (Index != ListOfWrongByteSize.length -1) {
							OutputHTML += "\n"
						}
					}
					document.getElementById("ViewMode_Error").hidden = false
					document.getElementById("HTML_Output_Error").value = OutputHTML
				}
		} else {
			OutputHTML = ""
			let ListOfInvalidLines = new Array()
			for (let Index = 0; Index < UserInputList.length; Index++) {
				if (!(RegExp(String2Regex_CorrectLine).test(UserInputList[Index][0]))) {
					ListOfInvalidLines.push(UserInputList[Index])
				}
			}
			OutputHTML += "Error: These lines contain invalid information:\n"
			for (let Index = 0; Index < ListOfInvalidLines.length; Index++) {
				OutputHTML += "Line " + BigInt(ListOfInvalidLines[Index][1] + 1).toString(10) + ": [" + ListOfInvalidLines[Index][0] + "]"
				if (Index != ListOfInvalidLines.length -1) {
					OutputHTML += "\n"
				}
			}
			document.getElementById("ViewMode_Error").hidden = false
			document.getElementById("HTML_Output_Error").value = OutputHTML
		}
	}
	//remove duplicate entries
		function RemoveDuplicateAddressEntry(ArrayWithAddresses) {
			//ArrayWithAddresses[Index] contains an array:
			//ArrayWithAddresses[Index][0] = starting address
			//ArrayWithAddresses[Index][1] = number of bytes
			//ArrayWithAddresses[Index][2] = description
			//ArrayWithAddresses[Index][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
			//ArrayWithAddresses[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
			
			//Add a flag mode for each item
				let DuplicateFlagArray = new Array()
				for (let Index = 0; Index < ArrayWithAddresses.length; Index++) {
					DuplicateFlagArray.push([ArrayWithAddresses[Index], false])
				}
				//DuplicateFlagArray[Index][0]: The original array:
				//DuplicateFlagArray[Index][0][0] = starting address
				//DuplicateFlagArray[Index][0][1] = number of bytes
				//DuplicateFlagArray[Index][0][2] = description
				//DuplicateFlagArray[Index][0][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
				//DuplicateFlagArray[Index][0][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
				//DuplicateFlagArray[Index][1]: duplicate flag
			//Now start flagging them
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] != true) {
						for (let Index2 = Index + 1; Index2 < DuplicateFlagArray.length; Index2++) {
							if ((DuplicateFlagArray[Index][0][0] == DuplicateFlagArray[Index2][0][0])&&(DuplicateFlagArray[Index][0][1] == DuplicateFlagArray[Index2][0][1])&&(DuplicateFlagArray[Index][0][2] == DuplicateFlagArray[Index2][0][2])) {
								DuplicateFlagArray[Index2][1] = true
							}
						}
					}
				}
			//Now remove ones flagged dups
				let OutputData = new Array()
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] == false) {
						OutputData.push(DuplicateFlagArray[Index][0])
					}
				}
			return OutputData
		}
//Other subfunctions
	//Remove stuff that is not address data
		function RemoveBlankCommentOrSpacesEntry(InputArray) {
			let OutputArray = new Array()
			for (index1 = 0; index1 < InputArray.length; index1++) {
				if ((/^(\s*)$|^()$|^(\s*;+.*)$/).test(InputArray[index1][0]) == false) {
					OutputArray.push(InputArray[index1])
				}
			}
			return OutputArray
		}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	//Escape
		function escapeHTMLChars(string) {
			//Should the user's input contains "<", ">", and "&", prevent the innerHTML from treating these as HTML tags/escapes
				string = string.replaceAll("&", "&amp;") //This must be done first, to avoid replacing already-replaced symbol's ampersand character.
				string = string.replaceAll("<", "&lt;")
				string = string.replaceAll(">", "&gt;")
				return string
		}
	//Sort functions
		//Start address
			function SortByStartAddr(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? -1 : 1;
				}
			}
			function SortByStartAddrRev(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? 1 : -1;
				}
			}
		//Size
			function SortBySize(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? -1 : 1;
				}
			}
			function SortBySizeRev(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? 1 : -1;
				}
			}
		//Description
			function SortByDescription(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? -1 : 1;
				}
			}
			function SortByDescriptionRev(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? 1 : -1;
				}
			}
		//Status
			function SortByStatus(a, b) {
				if (a[5] === b[5]) {
					return 0;
				} else {
					return (a[5] < b[5]) ? -1 : 1;
				}
			}
			function SortByStatusRev(a, b) {
				if (a[5] === b[5]) {
					return 0;
				} else {
					return (a[5] < b[5]) ? 1 : -1;
				}
			}
		//How many overlaps
			function SortByOverlapCount(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? -1 : 1;
				}
			}
			function SortByOverlapCountRev(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? 1 : -1;
				}
			}
	//Color status
		function ColorStatus(InputString) {
			switch (InputString) {
				case "Gap":
					return "#808080"
				case "NoOverlap":
					return "#008000"
				case "Overlap":
					return "#800000"
				default:
					return "#000080"
			
			}
		}
	//Filter
		function FilterAddress(InputArray) {
			let OutputArray = new Array()
			let FilterList = new Array()
			let ListOfFilters = document.getElementsByClassName("AddressFilter")
			for (let Index = 0; Index < ListOfFilters.length; Index++) {
				if (ListOfFilters[Index].checked) {
					FilterList.push(ListOfFilters[Index].dataset.filter_status)
				}
			}
			for (let Index = 0; Index < InputArray.length; Index++) {
				let IsFilterMatchFound = false
				for (let IndexFilterList = 0; (IndexFilterList < FilterList.length && IsFilterMatchFound == false); IndexFilterList++) {
					if (InputArray[Index][5] == FilterList[IndexFilterList]) {
						OutputArray.push(InputArray[Index])
						IsFilterMatchFound = true
					}
				}
			}
			return OutputArray
		}
//Other
	//These makes input text act like a number input, pressing UP/DOWN on the arrow keys to increment/decrement it, but with any radixes.
	//In order for this to apply, have these on the number input:
	//- Make sure the class contains "AnyRadixNumberInput"
	//- Specify what radix it is, have the custom attribute [data-input_number_radix="x"] where x
	//  is a radix number that can be any number 2-36. Examples include: 2 = binary, 10 = decimal (default), 16 = hexadecimal.
	//To get this to apply, use this:
	// window.onload = function(){ //Upon loading, apply the function to execute when the up/down arrow keys are pressed.
	//  UpDownArrowKeysIncrement()
	// }
		function UpDownArrowKeysIncrement() {
			let FocusedElement = document.activeElement;
			if(FocusedElement.addEventListener ) {
				FocusedElement.addEventListener('keydown',this.keyHandler_ArrowKeys,false);
			} else if(FocusedElement.attachEvent ) {
				FocusedElement.attachEvent('onkeydown',this.keyHandler_ArrowKeys);
			}
		}
	
		function keyHandler_ArrowKeys(e) {
			if (((e.code == "ArrowUp")||e.code == "ArrowDown")&&((/(^|\s.*?)AnyRadixNumberInput($|\s.*?)/).test(document.activeElement.className))) {
				let target;
				//Handle radix.
					let Radix = 10
					if ((/^\d+$/).test(document.activeElement.dataset.input_number_radix)) {
						Radix = parseInt(document.activeElement.dataset.input_number_radix)
					}
				let InputNumber = ParseBigIntValue(document.activeElement.value, Radix) //This gets the number
				if (!e) var e = window.event;
				if (e.target) target = e.target;
				else if (e.srcElement) target = e.srcElement;
				
				if(e.code == "ArrowUp") {
					InputNumber++
					e.preventDefault()	//Prevents the caret (blinking text cursor) from being placed at the beginning of the line.
				} else if(e.code == "ArrowDown") {
					InputNumber--
				}
				document.activeElement.value = InputNumber.toString(Radix).toUpperCase()
				document.activeElement.setSelectionRange(document.activeElement.value.length, document.activeElement.value.length)
				document.activeElement.onchange()
			}
		}
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
			return num <= min ? min : num >= max ? max : num;
	}
	function ScrollSVGGraph(event) {
		//if (instanceOfKeyboardEvent.shiftKey) {
			let StartAddressView = ParseBigIntValue(document.getElementById("ByteByByteViewStartingAddress").value, 16)
			
			let ScrollScaleFactor = 1n
			if (event.shiftKey == true) {
				ScrollScaleFactor = Setting_ByteView_NumberOfRows
			}
			if (event.deltaY > 0) {
				StartAddressView = StartAddressView + ScrollScaleFactor
				event.preventDefault()
			} else if (event.deltaY < 0) {
				StartAddressView = StartAddressView - ScrollScaleFactor
				event.preventDefault()
			}
			if (StartAddressView < 0n) {
				StartAddressView = 0n
			}
			document.getElementById("ByteByByteViewStartingAddress").value = StartAddressView.toString(16).toUpperCase()
			MainCode()
		//}
	}

	var Element_ScrollSVGGraph = document.getElementById("SVG_VectorGraph")
	Element_ScrollSVGGraph.onwheel = ScrollSVGGraph

</script>