<html>
	<head>
		<style>
			html {
			background-color: white;
			color: black;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid black;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
		</style>
	</head>
<body>
Enter a list of RAM addresses in the text area below. It must be formatted like this:
<table><tr><td><pre>&lt;Address&gt;	&lt;Size_in_bytes_Or_EndAddress&gt;	&lt;Description&gt;
&lt;Address&gt;	&lt;Size_in_bytes_Or_EndAddress&gt;	&lt;Description&gt;
&lt;Address&gt;	&lt;Size_in_bytes_Or_EndAddress&gt;	&lt;Description&gt;
[...]&leftarrow; Last item not to have line breaks!</pre></td></tr></table><br>
Note: Whitespace is TAB character, not a literal space character. Easy way to insert a tab character without switching focus is by holding <kbd>ALT</kbd>, type <kbd>9</kbd>, then let go <kbd>ALT</kbd><br><br>
Where:
<table><tr><td><pre>
Address = the RAM address, in hex, with or without the &ldquo;$&rdquo; prefix.
Size_in_bytes_Or_EndAddress = 
 -Enter [NumberOfBytes] for how many bytes taken in decimal, starting from [Address] and ending at [Address + Size_in_bytes - 1].
 -Enter [-EndAddress] to denote an ending address in hex.
Description = Brief description, don't use tabs here, as it is reserved for tab-seperated columns.

Note: HTML tags, elements and other reserved symbols apply here!</pre></td></tr></table><br>
<textarea id="UserInputList" cols="50" rows="10" oninput="DisplayAddress()"></textarea><br>
Sort address:<br>
<input type="radio" id="Address_Ascending" name="Address_Sort" onchange="DisplayAddress()" checked><label for="Address_Ascending">Ascending</label><br>
<input type="radio" id="Address_Descending" name="Address_Sort" onchange="DisplayAddress()"><label for="Address_Descending">Descending</label><br>
<hr>
<span id="Output"></span>


<script>

	function DisplayAddress() {
			var Output = ""
		//Obtain each list of items
			var ListOfUsedAddress = (document.getElementById("UserInputList").value).split('\n')
		//Check if all lines are valid format.
			var Index_ErrorLine = 0
			var AllLinesValid = true
			var NumberOfBytesValid = true
			while ((Index_ErrorLine < (ListOfUsedAddress.length))&&(AllLinesValid == true)) {
				if ((/^\$?[0-9a-fA-F]+?\t(\d+?|-\$?[0-9a-fA-F]+?)\t[^\t]+?$/.test(ListOfUsedAddress[Index_ErrorLine])) == false) {
					AllLinesValid = false
				}
				//Next
					Index_ErrorLine++
			}
		//Process each line.
			if (AllLinesValid == true) {
				//Each line is split into a sub-array
				//After this, we have:
				//ListOfUsedAddress[Index_WhichEntry][0] = address column
				//ListOfUsedAddress[Index_WhichEntry][1] = size column
				//ListOfUsedAddress[Index_WhichEntry][2] = description column
				//ListOfUsedAddress[Index_WhichEntry][3] = (internally) overlap status column
				//ListOfUsedAddress[Index_WhichEntry][4] = (internally) gap status
				//ListOfUsedAddress[Index_WhichEntry][5] = (internally) gap address
				//ListOfUsedAddress[Index_WhichEntry][6] = (internally) gap size
					var Index_WhichEntry = 0
					while (Index_WhichEntry < ListOfUsedAddress.length) {
						//Split each item in a row into separate elements.
							ListOfUsedAddress[Index_WhichEntry] = ListOfUsedAddress[Index_WhichEntry].split('\t')
						//Get starting address
							if ((/^\$[0-9a-fA-F]+$/).test(ListOfUsedAddress[Index_WhichEntry][0])) {
								//Remove the $ symbol.
									ListOfUsedAddress[Index_WhichEntry][0] = (ListOfUsedAddress[Index_WhichEntry][0]).substring(1)
							}
							ListOfUsedAddress[Index_WhichEntry][0] = BigInt("0x" + ListOfUsedAddress[Index_WhichEntry][0])
						//Number of bytes or ending address (if address is supplied, convert to number of bytes)
							if ((/^\d+$/).test(ListOfUsedAddress[Index_WhichEntry][1])) {
								//User enters a decimal number of bytes
									ListOfUsedAddress[Index_WhichEntry][1] = BigInt(ListOfUsedAddress[Index_WhichEntry][1])
							} else if ((/^-\$?[0-9a-fA-F]+$/).test(ListOfUsedAddress[Index_WhichEntry][1])) {
								//User enters an ending address
									//Remove the - symbol
										ListOfUsedAddress[Index_WhichEntry][1] = (ListOfUsedAddress[Index_WhichEntry][1]).substring(1)
									if ((/^\$[0-9a-fA-F]+$/).test(ListOfUsedAddress[Index_WhichEntry][1])) {
										//Remove the $ symbol
											ListOfUsedAddress[Index_WhichEntry][1] = (ListOfUsedAddress[Index_WhichEntry][1]).substring(1)
									}
									ListOfUsedAddress[Index_WhichEntry][1] = BigInt("0x" + ListOfUsedAddress[Index_WhichEntry][1]) - ListOfUsedAddress[Index_WhichEntry][0] + 1n
							}
							//Break out if the number of bytes is 0 or negative.
								if (ListOfUsedAddress[Index_WhichEntry][1] < 1n) {
									NumberOfBytesValid = false
								}
						//Add a new item on each row
							ListOfUsedAddress[Index_WhichEntry].push("", "", "", "")
						//Next
							Index_WhichEntry++
					}
				if ((NumberOfBytesValid == true)&&(AllLinesValid == true)) {
					//Sort each main item (each line; each entry containing address, number of bytes, and description) by address, ascending
					//initially so that we can easily check each address afterwards if they overlap or gapped.
						ListOfUsedAddress.sort(SortFunction);
					//check overlaps and gaps
						Index_WhichEntry = 1 //Since we always check an element before our current one, the first one does not have anything before that.
						ListOfUsedAddress[0][3] = "first"
						ListOfUsedAddress[0][4] = "first"
						while (Index_WhichEntry < ListOfUsedAddress.length) {
							//Check overlaps
								if ((ListOfUsedAddress[Index_WhichEntry][0]) > (ListOfUsedAddress[Index_WhichEntry - 1][0] + ListOfUsedAddress[Index_WhichEntry - 1][1] - 1n)) {
									ListOfUsedAddress[Index_WhichEntry][3] = "NoOverlap"
								} else {
									ListOfUsedAddress[Index_WhichEntry][3] = "Overlap"
									ListOfUsedAddress[Index_WhichEntry - 1][3] = "Overlap"
								}
							//Check gaps
								if ((ListOfUsedAddress[Index_WhichEntry][0] - 1n) == (ListOfUsedAddress[Index_WhichEntry - 1][0] + ListOfUsedAddress[Index_WhichEntry - 1][1] - 1n)) {
									//If the previous last byte address is -1 from our current address, therefore no address in between, say $60-$62 and $63-$64
										ListOfUsedAddress[Index_WhichEntry][4] = "NoGap"
										ListOfUsedAddress[Index_WhichEntry][5] = "---"
										ListOfUsedAddress[Index_WhichEntry][6] = "---"
								} else if ((ListOfUsedAddress[Index_WhichEntry][0] - 1n) > (ListOfUsedAddress[Index_WhichEntry - 1][0] + ListOfUsedAddress[Index_WhichEntry - 1][1] - 1n)) {
									//If there is a gap between last byte of the first range and second range ($60 and $62)
										ListOfUsedAddress[Index_WhichEntry][4] = "Gap"
										ListOfUsedAddress[Index_WhichEntry][5] = ListOfUsedAddress[Index_WhichEntry - 1][0] + ListOfUsedAddress[Index_WhichEntry - 1][1] //Start address
										ListOfUsedAddress[Index_WhichEntry][6] = ListOfUsedAddress[Index_WhichEntry][0] - ListOfUsedAddress[Index_WhichEntry][5] //Number of bytes (current address minus previous last byte address)
								}
							//Next
								Index_WhichEntry++
						}
					//Display output
						if (document.getElementById("Address_Descending").checked) {
							ListOfUsedAddress.reverse()
						}
						Output += "<table>"
						Output += "<tr><th>Address</th><th>Size(/EndAddress)</th><th>Description</th>"
						Index_WhichEntry = 0
						while (Index_WhichEntry < ListOfUsedAddress.length) {
							if (ListOfUsedAddress[Index_WhichEntry][4] == "Gap") {
								Output += "<tr>"
								Output += "<td bgcolor='C0C0C0'><kbd>$" + ListOfUsedAddress[Index_WhichEntry][5].toString(16).toUpperCase() +"</kbd> Gap</td>"
								Output += "<td><kbd>" + ListOfUsedAddress[Index_WhichEntry][6].toString(10) + "</kbd>"
								if (ListOfUsedAddress[Index_WhichEntry][6] > 1n) {
									Output += "/<kbd>$" + (ListOfUsedAddress[Index_WhichEntry][5] + ListOfUsedAddress[Index_WhichEntry][6] - 1n).toString(16).toUpperCase() + "</kbd>"
								}
								Output += "</td>"
								Output += "<td>Not listed</td>"
								Output += "</tr>"
							}
							Output += "<tr>"
							if (ListOfUsedAddress[Index_WhichEntry][3] != "Overlap") {
								Output += "<td>"
							} else {
								Output += "<td bgcolor='salmon'>"
							}
							Output += "<kbd>$" + ListOfUsedAddress[Index_WhichEntry][0].toString(16).toUpperCase() + "</kbd>"
							if (ListOfUsedAddress[Index_WhichEntry][3] == "Overlap") {
								Output += " Overlap detected!"
							}
							Output += "</td>"
							Output += "<td><kbd>" + ListOfUsedAddress[Index_WhichEntry][1].toString(10) + "</kbd>"
							if (ListOfUsedAddress[Index_WhichEntry][1] > 1n) {
								//Show end address if more than 1 byte
									Output += "/<kbd>$" + (ListOfUsedAddress[Index_WhichEntry][0] + ListOfUsedAddress[Index_WhichEntry][1] - 1n).toString(16).toUpperCase() + "</kbd>"
							}
							Output += "</td>"
							Output += "<td>" + ListOfUsedAddress[Index_WhichEntry][2] + "</td>"
							Output += "</tr>"
							
							//Next
								Index_WhichEntry++
						}
						
						Output += "</table>"
				} else {
					//Invalid number of bytes or an end address before the start address.
						Output += "Error! One of the items have an invalid number of bytes, or have end address being lower than the start address."
				}
			} else {
				//Display an error that one of the lines are off.
					Output += "Error! Format is wrong (empty lines, extra TAB character, empty entry), or entries using invalid characters."
			}
			
			document.getElementById("Output").innerHTML = Output
	}
	function SortFunction(a, b) {
		if (a[0] === b[0]) {
			return 0;
		}
		else {
			return (a[0] < b[0]) ? -1 : 1;
		}
	}
</script>