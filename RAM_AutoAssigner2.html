<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			select, option {
				font-family: monospace;
			}
			
			textarea {
				white-space: pre;
				overflow-wrap: normal;
				overflow-x: scroll;
			}
		</style>
	</head>
<body>


<p>This tool will take the provided freeram defines, and the list of unused RAM, and automatically find freeram and will assign each freeram defines to which address to use.</p>

<p>Make sure the supplied RAMs do not overlap.</p>

Format for freeram should be:<br>
<table><tr><td><pre>ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes_Decimal	Optional_min	Optional_max</pre></td></tr></table>

Where:
<ul>
<li><kbd>ASM_resource_name</kbd> is the name of an ASM resource. Can be any character but must not contain a linebreak or tab.</li>
<li><kbd>!RAM_Define</kbd> is the define name used in the ASM file that represents a RAM to use. Just like above, no linebreaks, no tabs.</li>
<li><kbd>Number_of_bytes_Decimal</kbd> is how many bytes the RAM it requires (contiguously), in decimal. Must be at least 1.</li>
<li>
	<kbd>Optional_min</kbd>: This is optional, either enter an address hex number (&ldquo;$&rdquo; is optional) or just &ldquo;-&rdquo; to nullify it. When a hex number is supplied, this forces
	the RAM to search for a freeram define to not have its starting address location below this address. This is useful if RAMs that an ASM resource must or must not reset during loading screens (black screen).
</li>
<li><kbd>Optional_max</kbd>: Same as above, but forces the location of a freeram define address not to have its ending byte greater than this address. Note: when both min and max are set, max must be greater than or equal to min.</li>
</ul>
Format for list of empty RAM should be (same as the address tracker):<br>
<table><tr><td><pre>Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description</pre></td></tr></table><br>
All of these ranges must NOT overlap.
<ul>
<li><kbd>Address</kbd> is the starting address. (dollar sign &ldquo;$&rdquo; is optional)</li>
<li><kbd>Size_or_ending_address</kbd> is the size or ending addresses (entering a decimal number results in number of bytes, and typing tilde &ldquo;~&rdquo;, before a hexadecimal number denotes an ending address (dollar sign &ldquo;$&rdquo; is optional))</li>
<li><kbd>Optional_description</kbd> is optional, will not be checked by this javascript at all. When the remove duplicate flags is checked here, will only check the location and size/ending address.</li>
</ul><br><br>
Notes:
<ul>
	<li>This tool will process each freeram defines from top to bottom order from the text, and the list of gaps at increasing address order. This means that the RAM at the top of the list will be assigned to the lowest address location that it can fit
	(unless if not, will state no suitable address is found)</li>
	<li>If you have gap ranges touching each other, like this:
	<table><tr><td><pre>
$7E0060	~$7E0061	Range 1
$7E0062	~$7E0063	Range 2 (notice that this range starts the byte after the last byte of the one above, no bytes between)</pre></td></tr></table>
	it will NOT merge them together and any freeram define set cannot cross the boundary where they touch. So a freeram that needs 3 or 4 bytes cannot fit here.</li>
</ul>

<table>
	<tr>
		<th>Enter your list of ASM resource freeram defines here.</th>
		<th>Enter your list of empty RAMs here.</th>
	</tr>
	<tr>
		<td>
			<textarea id="TextareaInput_FreeramDefines" oninput="RefreshAndMainCode()" cols="60" rows="15" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
		<td>
			<textarea id="TextareaInput_EmptyRams" oninput="RefreshAndMainCode()" cols="60" rows="15" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
		</td>
	</tr>
</table>
<div>Duplicate settings:
	<div><label><input type="checkbox" checked onchange="RefreshAndMainCode()" id="DuplicateSettings_Defines">Ignore duplicates for defines</label></div>
	<div><label><input type="checkbox" checked onchange="RefreshAndMainCode()" id="DuplicateSettings_EmptyRams">Ignore duplicates for gaps</label></div>

<table>
	<tr>
		<th>Freeram list settings</th>
		<th>Remaining gaps settings</th>
	</tr>
	<tr>
		<td>
			Filter:
			<div><label><input type="checkbox" onchange="MainCode()" checked id="FreeramDefine_Filter_Success">Successfully placed</label></div>
			<div><label><input type="checkbox" onchange="MainCode()" checked id="FreeramDefine_Filter_Failed">Failed to place</label></div>
			Sort:
			<select onchange="MainCode()">
				<option id="FreeramDefine_SortOption_None">None</option>
				<option id="FreeramDefine_SortOption_ResourceName" selected>Resource name</option>
				<option id="FreeramDefine_SortOption_Addr">By address</option>
				<option id="FreeramDefine_SortOption_Length">By number of bytes</option>
			</select><label><input type="checkbox" id="FreeramDefine_SortOption_Reverse" onchange="MainCode()">Reverse order</label><br><br>
			Output format: <select onchange="MainCode()">
				<optgroup label="ASM format">
					<option id="FreeramDefine_OutputFormatSetting_ASMFormat">ASM define</option>
				</optgroup>
				<optgroup label="Address tracker format">
					<option id="FreeramDefine_OutputFormatSetting_AddressTrackerLength">Address tracker format - length</option>
					<option id="FreeramDefine_OutputFormatSetting_AddressTrackerEnding">Address tracker format - end address</option>
				</optgroup>
			</select>
		</td>
		<td>
			Sort: <select onchange="MainCode()">
				<option id="Gaps_SortOption_ByAddr" selected>By start address</option>
				<option id="Gaps_SortOption_Size">By size</option>
			</select><label><input type="checkbox" id="Gaps_SortOption_Reverse" onchange="MainCode()">Reverse order</label><br><br>
			
			Size/ending address mode: <select onchange="MainCode()">
				<option id="Gaps_OutputFormatSetting_Size" selected>Size</option>
				<option id="Gaps_OutputFormatSetting_Ending">Ending</option>
				<option id="Gaps_OutputFormatSetting_Ending">Size and ending (&lt;size&gt;/-&lt;ending_address&gt;</option>
			</select>
		</td>
	</tr>
</table>
</div>
<hr>
<div id="OutputErrorMessage" hidden><pre id="OutputErrorMessage_Text" style="border: 1px solid white;"></pre></div>
<div id="OutputResults">
	<table>
		<tr>
			<th>Freeram defines result</th>
			<th>Remaining Empty RAMs result</th>
		</tr>
		<tr>
			<td>
				<table>
					<tr>
						<th colspan="2">Define Statistics</th>
					</tr>
					<tr>
						<td style="font-family: monospace">Total defines</td>
						<td style="font-family: monospace" id="Statistics_TotalDefines">0</td>
					</tr>
					<tr>
						<td style="font-family: monospace">Success</td>
						<td style="font-family: monospace" id="Statistics_Success">0</td>
					</tr>
					<tr>
						<td style="font-family: monospace">Failed</td>
						<td style="font-family: monospace" id="Statistics_Failed">0</td>
					</tr>
				</table>
				<span id="SomeDefinesFailedWarning" style="color: red; font-family: monospace" hidden>There are define(s) have failed to be assigned and they are not counted as consuming RAM</span>
				<textarea id="TextareaOutput_AssignedRAMs" cols="70" rows="15" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: #FFFFFF;" readonly></textarea>
				<div><button onclick="setClipboard(document.getElementById('TextareaOutput_AssignedRAMs').value)">Copy</button><span></span></div>
			</td>
			<td>
				<table>
					<tr>
						<th colspan="2">Empty RAM Statistics</th>
					</tr>
					<tr>
						<td style="font-family: monospace">Number of ranges before</td>
						<td style="font-family: monospace" id="Statistics_EmptyRamRangeCountBefore">0</td>
					</tr>
					<tr>
						<td style="font-family: monospace">Number of ranges after</td>
						<td style="font-family: monospace" id="Statistics_EmptyRamRangeCountAfter">0</td>
					</tr>
					<tr>
						<td style="font-family: monospace">Total bytes before</td>
						<td style="font-family: monospace" id="Statistics_EmptyRAMBytesBefore">0</td>
					</tr>
					<tr>
						<td style="font-family: monospace">Total bytes after</td>
						<td style="font-family: monospace">
							<span id="Statistics_EmptyRAMBytesAfter">0</span> (<span id="Statistics_EmptyRamBytesConsumed">0</span> consumed)
						</td>
					</tr>
				</table>
				<textarea id="TextareaOutput_ResultingGaps" cols="70" rows="15" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: #FFFFFF;" readonly></textarea>
				<div><button onclick="setClipboard(document.getElementById('TextareaOutput_ResultingGaps').value)">Copy</button><span></span></div>
			</td>
		</tr>
	</table>
</div>
<script>
	function keyHandler_Tab(e) {

		let target;
		if (!e) e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				let startPos = target.selectionStart;
				let endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	
	[...document.querySelectorAll("textarea")].forEach(Ele => {
		Ele.addEventListener("keydown", this.keyHandler_Tab, false)
	})
	
	let Saved_Data = {
		ListOfGaps: [],
		FreeramList: []
	}
	let NeedToUpdateLists = false
	function RefreshAndMainCode() {
		NeedToUpdateLists = true
		MainCode()
	}
	function MainCode() {
		let FreeramList = []
		let ListOfGaps = []
		let FailedPlaceHolderAddress = -Infinity
		let ProcessError = false
		document.getElementById("TextareaOutput_AssignedRAMs").value = ""
		let FreeramDefinePlacementCountSuccess = 0
		let FreeramDefinePlacementCountFailed = 0
		
		if (NeedToUpdateLists) {
			
			let InputText = document.getElementById("TextareaInput_FreeramDefines").value
			InputText = InputText.split("\n")
			FreeramList = InputText.map((Line, Index) => {
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!(/^[^\t]+\t![a-zA-Z\d_]+\t\d+(?:\t-|-?\$?[\dA-Fa-f]+){2}$/).test(Line)) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Invalid text, please check no mistyped character.",
						LineNumber: Index,
						SourceText: Line
					}
				}
				let PartsOfString = Line.split("\t")
				let ResourceName = PartsOfString[0]
				let DefineName = PartsOfString[1]
				let Length = ParseBigIntValue(PartsOfString[2].replace(/\$/, ""))
				if (Length < 1n) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Number of bytes must be at least 1",
						LineNumber: Index,
						SourceText: Line
					}
				}
				let MinAddress = -Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[3])) {
					MinAddress = ParseBigIntValue(PartsOfString[3].replace(/\$/, ""), 16)
				}
				let MaxAddress = Infinity
				if (/^-?\$?[\dA-Fa-f]+$/.test(PartsOfString[4])) {
					MaxAddress = ParseBigIntValue(PartsOfString[4].replace(/\$/, ""), 16)
				}
				if (MinAddress > MaxAddress) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Max address is before min address.",
						LineNumber: Index,
						SourceText: Line
					}
				}
				return {
					Type: "ValidItem",
					Status: "Failed",
					ResourceName: ResourceName,
					DefineName: DefineName,
					Length: Length,
					AssignedAddressStartPos: -Infinity,
					MinAddress: MinAddress,
					MaxAddress: MaxAddress,
					LineNumber: Index,
					SourceText: Line
				}
			})
			if (ProcessError) {
				let ListOfBadFreerams = FreeramList.filter(Item => Item.Type=="Error")
				let ErrorText = "Error! The following items below are invalid free RAM entries:\n"
				ListOfBadFreerams.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				});
				document.getElementById("OutputErrorMessage_Text").textContent = ErrorText
				document.getElementById("OutputErrorMessage").hidden = false
				document.getElementById("OutputResults").hidden = true
				return
			}
			FreeramList = FreeramList.filter(Item => Item.Type=="ValidItem") //Got all our data, 
			if (document.getElementById("DuplicateSettings_Defines").checked) {
				FreeramList = ((ItemsList) => {
					let DupeFree = []
					FreeramList.forEach(Item => {
						let DupedItemOriginal = DupeFree.find(Item2 => {
							if ((Item.ResourceName == Item2.ResourceName)&&(Item.DefineName == Item2.DefineName)&&(Item.Length == Item2.Length)&&(Item.Length == Item2.Length)&&(Item.MinAddress == Item2.MinAddress)&&(Item.MaxAddress == Item2.MaxAddress)) {
								return true
							}
						});
						if (typeof DupedItemOriginal == "undefined") {
							DupeFree.push(Item)
						}
					});
					return DupeFree
				})(FreeramList);
			}
			//FreeramList process are done.
			let Statistics_EmptyRAMBytesBefore_Count = 0n
			let ListOfGapsText = document.getElementById("TextareaInput_EmptyRams").value.split('\n')
			ListOfGaps = ListOfGapsText.map((Line, Index) => {
				let SourceText = Line
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!/^\s*-?\$?[\da-fA-F]+\t(?:\d+|\~-?\$?[\da-fA-F]+)(?:\t.*)?$/.test(Line)) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Line containing invalid information.",
						SourceText: SourceText,
						LineNumber: Index
					}
				
				}
				let LineExtracted = Line.replace(/^\s*/, "").split("\t")
				let StartAddress = ParseBigIntValue(LineExtracted[0].replace("$", ""), 16)
				let EndAddress = 0n
				let Length = 0n
				if (/^\d+$/.test(LineExtracted[1])) { //If Length is provided
					Length = ParseBigIntValue(LineExtracted[1], 10)
					EndAddress = StartAddress+Length-1n
				} else { //Otherwise if ending address provided
					EndAddress = ParseBigIntValue(LineExtracted[1].replace(/^~/, "").replace(/\$/, ""), 16)
					Length = EndAddress-StartAddress+1n
				}
				if (Length < 1n) {
					ProcessError = true
					return {
						Type: "Error",
						Reason: "Length less than 1 byte or ending address is less than start address",
						SourceText: SourceText,
						LineNumber: Index
					}
				}
				Statistics_EmptyRAMBytesBefore_Count += Length
				let Description = LineExtracted[2] ?? ""
				return {
					Type: "Gap",
					SourceText: SourceText,
					LineNumber: Index,
					StartAddress: StartAddress,
					Length: Length,
					EndAddress: EndAddress,
					ConflictsWith: []
				}
			})
			if (ProcessError) {
				let ListOfBadGaps = ListOfGaps.filter(Item => Item.Type=="Error")
				let ErrorText = "Error! The following items below are invalid entries of empty RAMs:\n"
				ListOfBadGaps.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: " + Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("OutputErrorMessage_Text").textContent = ErrorText
				document.getElementById("OutputErrorMessage").hidden = false
				document.getElementById("OutputResults").hidden = true
				return
			}
			ListOfGaps = ListOfGaps.filter(Item => Item.Type=="Gap")
			if (document.getElementById("DuplicateSettings_EmptyRams").checked) {
				ListOfGaps = ((ItemsList) => { //Remove dupes
					let DupeFree = []
					ListOfGaps.forEach(Item => {
						let DupedItemOriginal = DupeFree.find(Item2 => {
							if ((Item.StartAddress == Item2.StartAddress)&&(Item.Length == Item2.Length)&&(Item.Description == Item2.Description)) {
								return true
							}
						});
						if (typeof DupedItemOriginal == "undefined") {
							DupeFree.push(Item)
						}
					});
					return DupeFree
				})(ListOfGaps);
			}
			//ListOfGaps is done.
			//Check if ListOfGaps contains items that overlap
			{
				let l = ListOfGaps.length
				for (let i=0; i<l; i++) {
					let Item = ListOfGaps[i]
					for (let i2 = i+1; i2<l; i2++) {
						let Item2 = ListOfGaps[i2]
						if (CheckOverlap(Item.StartAddress, Item.EndAddress, Item2.StartAddress, Item2.EndAddress)) {
							Item.Type = "Overlap"
							Item2.Type = "Overlap"
							ProcessError = true
							Item.ConflictsWith.push({
								LineNumber: Item2.LineNumber,
								StartAddress: Item2.StartAddress,
								Length: Item2.Length,
								EndAddress: Item2.EndAddress,
								Description: Item2.Description,
								SourceText: Item2.SourceText,
							})
							Item2.ConflictsWith.push({
								LineNumber: Item.LineNumber,
								StartAddress: Item.StartAddress,
								Length: Item.Length,
								EndAddress: Item.EndAddress,
								Description: Item.Description,
								SourceText: Item.SourceText,
							})
						}
					}
				}
			}
			if (ProcessError) {
				let Overlaps = ListOfGaps.filter(Item => Item.Type=="Overlap")
				let ErrorText = "Error! The following items below are empty RAMs overlapping:\n"
				Overlaps.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]:\n\t;Conflicts with:\n"
					Item.ConflictsWith.forEach((Item2, Index2, Arr2) => {
						ErrorText += "\t;Line " + (Item2.LineNumber+1).toString(10) + " [" + Item2.SourceText + "]"
						if (Index2 != Arr2.length-1) {
							ErrorText += "\n"
						}
					})
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("OutputErrorMessage_Text").textContent = ErrorText
				document.getElementById("OutputErrorMessage").hidden = false
				document.getElementById("OutputResults").hidden = true
				return
			}
			let Statistics_EmptyRamRangeCountBefore_Count = ListOfGaps.length
			document.getElementById("Statistics_EmptyRamRangeCountBefore").textContent = Statistics_EmptyRamRangeCountBefore_Count.toString(10)
			document.getElementById("Statistics_EmptyRAMBytesBefore").textContent = Statistics_EmptyRAMBytesBefore_Count.toString(10)
			
			document.getElementById("OutputErrorMessage_Text").textContent = ""
			document.getElementById("OutputErrorMessage").hidden = true
			document.getElementById("OutputResults").hidden = false
			
			if (FreeramList.length == 0 || ListOfGaps.length == 0) { //Prevent ListOfGaps[0] causing an exception
				return
			}
			//Both inputs done. Loop through FreeramList and place them in ListOfGaps
			//Sort, this makes it consistent that bytes will be used from low to high addresses when one define have multiple suitable ranges.
			ListOfGaps.sort((a,b) => Number(a.StartAddress - b.StartAddress))
			
			//We need this later for sorting by placed addresses, and because we're dealing with bigint and it cannot represent -Infinity or NaN.
			//Basically, if any define exists having its address assigned failed, instead of using -Infinity, it simply uses Range_With_Lowest_Start_AddressNumber-1.
			FailedPlaceHolderAddress = ListOfGaps[0].StartAddress-1n
			
			
			//Now place the freeram at a given gap address, and update the gaps list
			let l = FreeramList.length
			for (let i=0; i<l; i++) { //Loop each freeram define list
				let ASMFreeramDefine = FreeramList[i]
				for (let i2 = 0; i2<ListOfGaps.length; i2++) { //Loop each RAM gaps
					//^Now, I use ListOfGaps.length instead of "let l2 = ListOfGaps.length" because this array length changes as we successfully
					//assign a define to a RAM.
					let GapItem = ListOfGaps[i2]
					//Set up start and end points, accounting for potential min and max addresses
					let StartPos = GapItem.StartAddress
					if (ASMFreeramDefine.MinAddress != -Infinity && StartPos < ASMFreeramDefine.MinAddress) {
						StartPos = ASMFreeramDefine.MinAddress
					}
					let EndPos = GapItem.StartAddress + GapItem.Length-1n
					if (ASMFreeramDefine.MaxAddress != Infinity && EndPos > ASMFreeramDefine.MaxAddress) {
						EndPos = ASMFreeramDefine.MaxAddress
					}
					
					//Get the number of bytes between start and end
					let SizeAvailableSpace = EndPos-StartPos+1n
					if (ASMFreeramDefine.Length <= SizeAvailableSpace) { //If it can fit
						ASMFreeramDefine.AssignedAddressStartPos = StartPos //Freeram have been successfully placed.
						ASMFreeramDefine.Status = "Success"
						IsPlacedUsageSuccessful = true
						
						//modify the empty RAM array. This can potentially split the RAM range into 2 ranges.
						let SplittedRamBeforeStart = {
							StartAddress: GapItem.StartAddress,
							Length: StartPos - GapItem.StartAddress,
							EndAddress: (GapItem.StartAddress) + (StartPos - GapItem.StartAddress) -1n
						}
						
						//find if there will be empty RAM between ASMFreeramDefine.StartingAddress and ASMFreeramDefine.EndingAddress
						//example ASMFreeramDefine 2 bytes used on 7e0060. The GapItem is 4 bytes at 7e0060
						//7e0060 used
						//7e0061 used
						//7e0062 gap
						//7e0063 gap
						let SplittedRamAfterEnd = {
							StartAddress: ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length, //First byte after last used byte.
							Length: GapItem.StartAddress+GapItem.Length - (ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length),
							EndAddress: (ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length) + (GapItem.StartAddress+GapItem.Length - (ASMFreeramDefine.AssignedAddressStartPos + ASMFreeramDefine.Length)) -1n
						}
						if (SplittedRamBeforeStart.Length < 1n && SplittedRamAfterEnd.Length < 1n) { //Entire range consumed (e.g. all 4 bytes of 7E0060-$7E0063 used up by one define)
							ListOfGaps.splice(i2, 1) //Delete the RAM, it is all used up
						} else if (SplittedRamBeforeStart.Length >= 1n && SplittedRamAfterEnd.Length < 1n) { //Splitted RAM have empty bytes before the used RAM, but up to the end is used
							ListOfGaps.splice(i2, 1, SplittedRamBeforeStart)
						} else if (SplittedRamBeforeStart.Length < 1n && SplittedRamAfterEnd.Length >= 1n) { //Beginning parts of the freeram used up, but leaves a gap between last used byte and last freeram
							ListOfGaps.splice(i2, 1, SplittedRamAfterEnd)
						} else if (SplittedRamBeforeStart.Length >= 1n && SplittedRamAfterEnd.Length >= 1n) { //Split the RAM so both before and after usage there are gaps on either side
							ListOfGaps.splice(i2, 1, SplittedRamBeforeStart, SplittedRamAfterEnd)
						}
						break
					} else { //If not, potentially stop the loop entirely and go to next RAM define
						if (ASMFreeramDefine.MaxAddress != Infinity && StartPos+ASMFreeramDefine.Length-1n > ASMFreeramDefine.MaxAddress) {
							//If last byte beyond the max address, it cannot fit and all later empty RAMs are beyond this
							break
						}
					}
				}
			}
			
			
			FreeramList.forEach(Item => {
				if (Item.AssignedAddressStartPos != -Infinity) {
					FreeramDefinePlacementCountSuccess++
					Item.AssignedAddressStartPos_SafeSort = Item.AssignedAddressStartPos
				} else {
					FreeramDefinePlacementCountFailed++
					Item.AssignedAddressStartPos_SafeSort = FailedPlaceHolderAddress
				}
			});
			document.getElementById("SomeDefinesFailedWarning").hidden = true
			if (FreeramDefinePlacementCountFailed > 0) {
				document.getElementById("SomeDefinesFailedWarning").hidden = false
			}
			let Statistics_EmptyRAMBytesAfter_Count = 0n
			ListOfGaps.forEach(Gap => Statistics_EmptyRAMBytesAfter_Count += Gap.Length)
			document.getElementById("Statistics_EmptyRAMBytesAfter").textContent = Statistics_EmptyRAMBytesAfter_Count.toString(10)
			document.getElementById("Statistics_EmptyRamBytesConsumed").textContent = (Statistics_EmptyRAMBytesBefore_Count-Statistics_EmptyRAMBytesAfter_Count).toString(10)
			
			
			
			Saved_Data.FreeramList = FreeramList
			Saved_Data.ListOfGaps = ListOfGaps
		} else {
			ListOfGaps = Save_Data.ListOfGaps
			FreeramList = Save_Data.FreeramList
		}
		//Sorter (freeram defines)
			let ReverseSort_Defines = document.getElementById("FreeramDefine_SortOption_Reverse").checked ? -1 : 1
			
			FreeramListOutput = FreeramList.filter(Item => document.getElementById("FreeramDefine_Filter_" + Item.Status).checked)
			if (document.getElementById("FreeramDefine_SortOption_ResourceName").selected) {
				document.getElementById("FreeramDefine_SortOption_Reverse").disabled = false
				FreeramListOutput.sort((a,b) => {
					if (a.ResourceName === b.ResourceName) {
						return 0
					}
					return ((a.ResourceName < b.ResourceName) ? -1 : 1)*ReverseSort_Defines
				})
			} else if (document.getElementById("FreeramDefine_SortOption_Addr").selected) {
				document.getElementById("FreeramDefine_SortOption_Reverse").disabled = false
				FreeramListOutput.sort((a,b) => Number(a.AssignedAddressStartPos_SafeSort - b.AssignedAddressStartPos_SafeSort)*ReverseSort_Defines)
			} else if (document.getElementById("FreeramDefine_SortOption_Length").checked) {
				document.getElementById("FreeramDefine_SortOption_Reverse").disabled = false
				FreeramListOutput.sort((a,b) => Number(a.Length - b.Length)*ReverseSort_Defines)
			} else {
				document.getElementById("FreeramDefine_SortOption_Reverse").disabled = true
			}
			
		//Output
			let OutputString = ""
			FreeramListOutput.forEach((PlacedRAM, Index, Arr) => { //Get text and count how many success and fails
				if (PlacedRAM.AssignedAddressStartPos != -Infinity) {
					if (document.getElementById("FreeramDefine_OutputFormatSetting_ASMFormat").selected) {
						OutputString += PlacedRAM.DefineName + " = " + BigIntToStringSignedHex(PlacedRAM.AssignedAddressStartPos) + "\t; [" + PlacedRAM.Length + " byte"
						if (PlacedRAM.Length > 1n) {
							OutputString += "s" //plural
						}
						OutputString += "] " + PlacedRAM.ResourceName + " (" + PlacedRAM.DefineName + ")"
					} else {
						OutputString += BigIntToStringSignedHex(PlacedRAM.AssignedAddressStartPos) + "\t"
						if (document.getElementById("FreeramDefine_OutputFormatSetting_AddressTrackerLength").selected) {
							OutputString += PlacedRAM.Length
						} else if (document.getElementById("FreeramDefine_OutputFormatSetting_AddressTrackerEnding").selected) {
							OutputString += "~" + BigIntToStringSignedHex(PlacedRAM.AssignedAddressStartPos + PlacedRAM.Length -1n)
						}
						OutputString += "\t" + PlacedRAM.ResourceName
					}
				} else {
					OutputString += ";[" + PlacedRAM.SourceText + "]: Error! No suitable RAM found. "
				}
				if (Index != Arr.length-1) {
					OutputString += "\n"
				}
			})
			document.getElementById("TextareaOutput_AssignedRAMs").value = OutputString
			document.getElementById("Statistics_TotalDefines").textContent = FreeramList.length.toString(10)
			document.getElementById("Statistics_Success").textContent = FreeramDefinePlacementCountSuccess.toString(10)
			document.getElementById("Statistics_Failed").textContent = FreeramDefinePlacementCountFailed.toString(10)
		//Display the remaining gaps
			document.getElementById("Statistics_EmptyRamRangeCountAfter").textContent = ListOfGaps.length.toString(10)
			let OutputListOfGaps = null
			let ReverseSort_Freeram = document.getElementById("Gaps_SortOption_Reverse").checked ? -1 : 1
			
			//Sorting... ish
			if (document.getElementById("Gaps_SortOption_ByAddr").selected && document.getElementById("Gaps_SortOption_Reverse").checked) {
				//It's presorted during processing, worried about stability? No worries! Overlaps not allowed, thus either dupes are ignored or causes an error!
				OutputListOfGaps = ListOfGaps.toReversed()
			} else if (document.getElementById("Gaps_SortOption_Size").selected) {
				OutputListOfGaps = ListOfGaps.toSorted((a,b) => Number(a.Length - b.Length)*ReverseSort_Freeram)
			} else {
				OutputListOfGaps = ListOfGaps
			}
			OutputString = ""
			OutputListOfGaps.forEach((EmptyRam, Index, Arr) => {
				OutputString += BigIntToStringSignedHex(EmptyRam.StartAddress) + "\t"
				if (document.getElementById("Gaps_OutputFormatSetting_Size").selected) {
					OutputString += EmptyRam.Length.toString(10)
				} else if (document.getElementById("Gaps_OutputFormatSetting_Ending").selected) {
					OutputString += "~" + BigIntToStringSignedHex(EmptyRam.EndAddress)
				} else {
					OutputString += EmptyRam.Length.toString(10) + "/~" + BigIntToStringSignedHex(EmptyRam.EndAddress)
				}
				OutputString += "\tGap"
				if (Index != Arr.length-1) {
					OutputString += "\n"
				}
			})
			document.getElementById("TextareaOutput_ResultingGaps").value = OutputString
	}
//Helper
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function BigIntToStringSignedHex(BigIntVal) {
		//Converts a bigint value into a signed ASM-styled hex number:
		//16n -> "$10"
		//-16n -> "-$10"
		let StringOutput = ""
		if (BigIntVal >= 0n) {
			StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
		} else {
			StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
		}
		return StringOutput
	}
	function DeleteCopyMessage(HTMLElement) {
		HTMLElement.textContent = ""
	}
	
	function setClipboard(String) {
		//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
		const type = "text/plain";
		const blob = new Blob([String], { type });
		const data = [new ClipboardItem({ [type]: blob })];
		
		let EventElement = event.target
		let CopiedMessage = EventElement.parentNode.querySelector("span")
	
		navigator.clipboard.write(data).then(
			((EventElement) => {
			/* success */
				CopiedMessage.textContent = "Copied!"
				CopiedMessage.style.color = "#00FF00"
				setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
			}).bind(null, EventElement),
			((EventElement) => {
			/* failure */
				CopiedMessage.textContent = "Failed!"
				CopiedMessage.style.color = "#FF0000"
				setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
			}).bind(null, EventElement)
		);
	}
</script>