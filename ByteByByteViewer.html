<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
		</style>
	</head>
<body>
	<h1 style="text-align: center;">Byte by byte viewer</h1><br>
	
<p>This lets you view information in a byte-by-byte format (shows each consecutive neighboring addresses) and how they are used</p>

<p>Format to paste the text to view it is the same as <kbd>Addresser.html</kbd>.</p>

<textarea id="UserInputList" cols="75" rows="30" oninput="MainCode()"></textarea><br><br>

<label><input type="checkbox" checked id="CleanDuplicateEntries" onchange="MainCode()"><abbr title="Any lines that are identical copies are ignored and not flagged as an overlap.">Ignore duplicates</abbr></label><br>
<label><input type="checkbox" id="EscapeHTMLTagsAndEscapes" onchange="MainCode()">Escape html tags and escape characters for table description (this prevents potential invalid opening/closing HTML tags from breaking the table).</label><br><br>

sort by (for table only):<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_None" checked>Keep order you sent</label><br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_StartAddress">Starting address</label> (<label><input type="radio" name="Sorter" id="Sort_StartAddress_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Size">Size</label> (<label><input type="radio" name="Sorter" id="Sort_Size_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_Description">Description</label> (<label><input type="radio" name="Sorter" id="Sort_Description_Reverse" onchange="MainCode()">reverse</label>)<br>
<label><input type="radio" onchange="MainCode()" name="Sorter" id="Sort_HowManyOverlaps">How many overlaps</label> (<label><input type="radio" name="Sorter" id="Sort_HowManyOverlaps_Reverse" onchange="MainCode()">reverse</label>)<br>


<hr>
<span id="OutputSpanTag"></span>
<script>
//Tab key to make it not switch the focus and actually insert a tab character.
	window.onload = function(){    
		var addressList = document.getElementById("UserInputList");
		if(addressList.addEventListener ) {
			addressList.addEventListener('keydown',this.keyHandler,false);
		} else if(addressList.attachEvent ) {
			addressList.attachEvent('onkeydown',this.keyHandler);
		}
	}

	function keyHandler(e) {

		var target;
		if (!e) var e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				var startPos = target.selectionStart;
				var endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
//Regex stuff
	String2Regex_CorrectLine = "^\\$?[0-9A-Fa-f]+\\t(\\d+|-\\$?[0-9A-Fa-f]+)(\\t[^\\t]*?)?$"
	String2Regex_GetStartingAddress = "(?<=^\\$?)[0-9A-Fa-f]+"
	String2Regex_GetNumberOfBytesOrEndingAddress = "(?<=^\\$?[0-9A-Fa-f]+\\t)(\\d+|-\\$?[0-9A-Fa-f]+)"
	String2Regex_GetDiscription = "(?<=^[^\\t]+\\t[^\\t]+\\t)[^\\t]+$"
//Main functions
	function MainCode() {
		let OutputHTML = ""
		let ListOfAddress = new Array()
	//Get each line of text, will ignore items with just spaces, or spaces followed by comma.
		let UserInputList = RemoveBlankCommentOrSpacesEntry(document.getElementById("UserInputList").value.split('\n'))
	//Check if all lines are correct.
		let IsAllStringsValid = true
		for (let Index = 0; Index < UserInputList.length; Index++) {
			if (!(RegExp(String2Regex_CorrectLine).test(UserInputList[Index]))) {
				IsAllStringsValid = false
			}
		}
		if (IsAllStringsValid) {
			//Verify that the number of bytes/ending address are correct.
			//Number of bytes should be at least 1, and ending address not to be less than the starting address.
			//Easy way is to have them all be number of bytes.
			
			//However, we need to convert the first two columns, the address and the number of bytes or ending address
			//first.
				for (let Index = 0; Index < UserInputList.length; Index++) {
					let StartAddress = BigInt("0x" + UserInputList[Index].match(RegExp(String2Regex_GetStartingAddress))[0])
					let NumbOfBytesOrEndAddress_String = UserInputList[Index].match(RegExp(String2Regex_GetNumberOfBytesOrEndingAddress))[0]
					let NumberOfBytes = 0n
					if ((/^\d+$/).test(NumbOfBytesOrEndAddress_String)) {
						NumberOfBytes = BigInt(NumbOfBytesOrEndAddress_String)
					} else {
						let EndingAddressString = NumbOfBytesOrEndAddress_String.replace(/-\$?/, "")
						NumberOfBytes = BigInt("0x" + EndingAddressString) - StartAddress + 1n
					}
					let Description = ""
					if ((RegExp(String2Regex_GetDiscription)).test(UserInputList[Index])) {
						Description += UserInputList[Index].match(RegExp(String2Regex_GetDiscription))[0]
					}
					ListOfAddress.push([StartAddress, NumberOfBytes, Description, [], -1])
				}
			//Clean duplicates
				if (document.getElementById("CleanDuplicateEntries").checked) {
					ListOfAddress = RemoveDuplicateAddressEntry(ListOfAddress)
				}
			//Number the items (excluding duplicates when that checkbox is checked)
				for (let Index = 0; Index < ListOfAddress.length; Index++) {
					ListOfAddress[Index][4] = Index
				}
			//ListOfAddress[Index] now contains an array:
			//ListOfAddress[Index][0] = starting address
			//ListOfAddress[Index][1] = number of bytes
			//ListOfAddress[Index][2] = description
			//ListOfAddress[Index][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
			//ListOfAddress[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
			//
			//Let's check if any had wrong number of bytes or ending address
				let IsNumberOfBytesCorrectOnAll = true
				for (let Index = 0; (Index < ListOfAddress.length&& IsNumberOfBytesCorrectOnAll == true); Index++) {
					if (ListOfAddress[Index][1] < 1n) {
						IsNumberOfBytesCorrectOnAll = false
					}
				}
			//If all number of bytes are valid
				if (IsNumberOfBytesCorrectOnAll) {
					//Check if any address overlaps another
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							for (Index2 = Index + 1; Index2 < ListOfAddress.length; Index2++) {
								if (CheckOverlap(ListOfAddress[Index][0], ListOfAddress[Index][0] + ListOfAddress[Index][1] -1n, ListOfAddress[Index2][0], ListOfAddress[Index2][0] + ListOfAddress[Index2][1] -1n)) {
									//Write each other's overlap list
										ListOfAddress[Index][3].push(ListOfAddress[Index2][4])
										ListOfAddress[Index2][3].push(ListOfAddress[Index][4])
								}
							}
						}
					//Sort it
						if (document.getElementById("Sort_StartAddress").checked) {
							ListOfAddress.sort(SortByStartAddr)
						} else if (document.getElementById("Sort_StartAddress_Reverse").checked) {
							ListOfAddress.sort(SortByStartAddrRev)
						} else if (document.getElementById("Sort_Size").checked) {
							ListOfAddress.sort(SortBySize)
						} else if (document.getElementById("Sort_Size_Reverse").checked) {
							ListOfAddress.sort(SortBySizeRev)
						} else if (document.getElementById("Sort_Description").checked) {
							ListOfAddress.sort(SortByDescription)
						} else if (document.getElementById("Sort_Description_Reverse").checked) {
							ListOfAddress.sort(SortByDescriptionRev)
						} else if (document.getElementById("Sort_HowManyOverlaps").checked) {
							ListOfAddress.sort(SortByOverlapCount)
						} else if (document.getElementById("Sort_HowManyOverlaps_Reverse").checked) {
							ListOfAddress.sort(SortByOverlapCountRev)
						}
					//Now display it
						OutputHTML += "<table>"
						OutputHTML += "<tr><th>Item number</th><th>Starting address</th><th>Number of bytes(/Ending address)</th><th>Description</th><th>List of item numbers overlaps with</th></tr>"
						for (let Index = 0; Index < ListOfAddress.length; Index++) {
							OutputHTML += "<tr>"
							//Item number
								OutputHTML += "<td><kbd>AddressTrackerItem_"+ BigInt(ListOfAddress[Index][4]).toString(10) + "</kbd></td>"
							//Start address
								OutputHTML += "<td><kbd>$" + ListOfAddress[Index][0].toString(16).toUpperCase() + "</kbd></td>"
							//Number of bytes/ending address
								OutputHTML += "<td>"
								OutputHTML += "<kbd>" + ListOfAddress[Index][1].toString(10) + "</kbd>"
								if (ListOfAddress[Index][1] > 1n) {
									OutputHTML += "/<kbd>$" + (ListOfAddress[Index][0] + ListOfAddress[Index][1] - 1n).toString(16).toUpperCase() + "</kbd>"
								}
								OutputHTML += "</td>"
							//Description
								OutputHTML += "<td>"
								if (document.getElementById("EscapeHTMLTagsAndEscapes").checked) {
									OutputHTML += escapeHTMLChars(ListOfAddress[Index][2])
								} else {
									OutputHTML += ListOfAddress[Index][2]
								}
								OutputHTML += "</td>"
							//Overlaps
								OutputHTML += "<td>"
								if (ListOfAddress[Index][3].length == 0) {
									OutputHTML += "No overlaps."
								} else {
									OutputHTML += "Conflicts with item number(s) "
									for (Index2 = 0; Index2 < ListOfAddress[Index][3].length; Index2++) {
										OutputHTML += "<kbd>" + BigInt(ListOfAddress[Index][3][Index2]).toString(10) + "</kbd>"
										if (Index2 != ListOfAddress[Index][3].length -1) {
											OutputHTML += ", "
										}
									}
									OutputHTML += " (Number of stuff it conflicted: " + BigInt(ListOfAddress[Index][3].length).toString(10) + ")"
								}
								OutputHTML += "</td>"
							OutputHTML += "</tr>"
						}
						OutputHTML += "</table>"
				} else {
					OutputHTML += "<kbd>Error: One or more of the lines have invalid number of bytes or ending address.</kbd>"
				}
		} else {
			OutputHTML += "<kbd>Error: One or more of the lines have invalid information.</kbd>"
		}
		document.getElementById("OutputSpanTag").innerHTML = OutputHTML
	}
	//remove duplicate entries
		function RemoveDuplicateAddressEntry(ArrayWithAddresses) {
			//ArrayWithAddresses[Index] contains an array:
			//ArrayWithAddresses[Index][0] = starting address
			//ArrayWithAddresses[Index][1] = number of bytes
			//ArrayWithAddresses[Index][2] = description
			//ArrayWithAddresses[Index][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
			//ArrayWithAddresses[Index][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
			
			//Add a flag mode for each item
				let DuplicateFlagArray = new Array()
				for (let Index = 0; Index < ArrayWithAddresses.length; Index++) {
					DuplicateFlagArray.push([ArrayWithAddresses[Index], false])
				}
				//DuplicateFlagArray[Index][0]: The original array:
				//DuplicateFlagArray[Index][0][0] = starting address
				//DuplicateFlagArray[Index][0][1] = number of bytes
				//DuplicateFlagArray[Index][0][2] = description
				//DuplicateFlagArray[Index][0][3] = sub-array listing any overlaps (will contain a list of index numbers). If none, array is empty with length of 0.
				//DuplicateFlagArray[Index][0][4] = Item number, an ID number in the order of the user entering the list of used RAM. Starts at 0.
				//DuplicateFlagArray[Index][1]: duplicate flag
			//Now start flagging them
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] != true) {
						for (let Index2 = Index + 1; Index2 < DuplicateFlagArray.length; Index2++) {
							if ((DuplicateFlagArray[Index][0][0] == DuplicateFlagArray[Index2][0][0])&&(DuplicateFlagArray[Index][0][1] == DuplicateFlagArray[Index2][0][1])&&(DuplicateFlagArray[Index][0][2] == DuplicateFlagArray[Index2][0][2])) {
								DuplicateFlagArray[Index2][1] = true
							}
						}
					}
				}
			//Now remove ones flagged dups
				let OutputData = new Array()
				for (let Index = 0; Index < DuplicateFlagArray.length; Index++) {
					if (DuplicateFlagArray[Index][1] == false) {
						OutputData.push(DuplicateFlagArray[Index][0])
					}
				}
			return OutputData
		}
//Other subfunctions
	//Remove stuff that is not address data
		function RemoveBlankCommentOrSpacesEntry(InputArray) {
			let OutputArray = new Array()
			let index1 = 0
			let index2 = 0
			while (index1 < InputArray.length) {
				if ((/^(\s*)$|^()$|^(\s*;+.*)$/).test(InputArray[index1]) == false) {
					OutputArray.push(InputArray[index1])
					index2++
				}
				index1++
			}
			return OutputArray
		}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	//Escape
		function escapeHTMLChars(string) {
			//Should the user's input contains "<", ">", and "&", prevent the innerHTML from treating these as HTML tags/escapes
				string = string.replaceAll("&", "&amp;") //This must be done first, to avoid replacing already-replaced symbol's ampersand character.
				string = string.replaceAll("<", "&lt;")
				string = string.replaceAll(">", "&gt;")
				return string
		}
	//Sort functions
		//Start address
			function SortByStartAddr(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? -1 : 1;
				}
			}
			function SortByStartAddrRev(a, b) {
				if (a[0] === b[0]) {
					return 0;
				} else {
					return (a[0] < b[0]) ? 1 : -1;
				}
			}
		//Size
			function SortBySize(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? -1 : 1;
				}
			}
			function SortBySizeRev(a, b) {
				if (a[1] === b[1]) {
					return 0;
				} else {
					return (a[1] < b[1]) ? 1 : -1;
				}
			}
		//Description
			function SortByDescription(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? -1 : 1;
				}
			}
			function SortByDescriptionRev(a, b) {
				if (a[2] === b[2]) {
					return 0;
				} else {
					return (a[2] < b[2]) ? 1 : -1;
				}
			}
		//How many overlaps
			function SortByOverlapCount(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? -1 : 1;
				}
			}
			function SortByOverlapCountRev(a, b) {
				if (a[3].length === b[3].length) {
					return 0;
				} else {
					return (a[3].length < b[3].length) ? 1 : -1;
				}
			}
</script>