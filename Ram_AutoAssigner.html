<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			abbr{cursor: help;}
		</style>
	</head>
<body>

<p>This tool will take the provided freeram defines, and the list of unused RAM, and automatically find freeram and will assign each freeram defines to which address to use.</p>

<p>Make sure the supplied RAMs do not overlap.</p>

Format for freeram should be:<br>
<table><tr><td><pre>ASM_resource_name	!RAM_Define	Number_of_bytes	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes	Optional_min	Optional_max
ASM_resource_name	!RAM_Define	Number_of_bytes	Optional_min	Optional_max</pre></td></tr></table>

Where:
<ul>
<li><kbd>ASM_resource_name</kbd> is the name of an ASM resource</li>
<li><kbd>!RAM_Define</kbd> is the define used in the ASM file that represents a RAM to use</li>
<li><kbd>Number_of_bytes</kbd> is how many bytes the RAM it requires. Must be at least 1.</li>
<li>
	<kbd>Optional_min</kbd> and <kbd>Optional_max</kbd> are optional (use a hyphen &ldquo;-&rdquo; on each of them you want them to not applied, tab rule still applies). These are
	addresses so that the starting byte of a freeram are not to be below minimum and the last byte of freeram not to exceed the maximum, therefore conditioning
	the search in limited area. This is very useful for looking for RAM that should or shouldn't reset during loading screens.</li>
</ul>
Format for list of empty RAM should be:<br>
<table><tr><td><pre>Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description
Address	Size_or_ending_address	Optional_description</pre></td></tr></table><br>
All of these ranges must NOT overlap.
<ul>
<li><kbd>Address</kbd> is the starting address</li>
<li><kbd>Size_or_ending_address</kbd> is the size or ending addresses (enter a decimal number results in number of bytes, and typing hyphen, before a hexadecimal number denotes a range (dollar sign &ldquo;$&rdquo; is optional))</li>
<li><kbd>Optional_description</kbd> is optional, will not be checked by this javascript at all. However, tabs are still required.</li>
</ul>
<table>
	<tr>
		<th>Enter your list of ASM resource freeram defines here.</th>
		<th>Enter your list of empty RAMs here.</th>
	</tr>
	<tr>
		<td><textarea id="ListOfFreeramDefines" cols="75" rows="30" oninput="MainCode()"></textarea></td>
		<td><textarea id="ListOfUnusedRam" cols="75" rows="30" oninput="MainCode()"></textarea></td>
	</tr>
</table>
Sort:<br>
<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_None">Keep the same order of your defines</label><br>
<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_ByResourceName" checked>By Resource name</label> (<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_ByResourceName_Reverse">Reverse</label>)<br>
<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_ByAddress" >By address and out-of-RAM state</label> (<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_ByAddress_Reverse">Reverse</label>)<br>
<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_BySize" >By number of bytes</label> (<label><input onchange="MainCode()" type="radio" name="SortSetting_Output" id="Sort_BySize_Reverse">Reverse</label>)<br>
<hr>
<textarea readonly id="Output_AssignedRAMs" cols="150" rows="30" hidden></textarea>


<script>
	const String2Regex_GetASMResourceName = "[^\\t]+"
	const String2Regex_GetRAMDefine = "![^\\t]+"
	const String2Regex_GetNumberOfBytes = "\\d+"
	const String2Regex_GetOptionalHexAddress = "(\\$?[A-Fa-f\\d]+|-)"
	const String2Regex_GetNumberOfBytesOrEnding = "(\\d+|-\\$?[A-Fa-f\\d]+)"
	
	const String2Regex_GetEmptyRAM_Address = "\\$?[A-Fa-f\\d]+"
//Tab key to make it not switch the focus and actually insert a tab character.
	window.onload = function(){
		var DefinesList = document.getElementById("ListOfFreeramDefines");
		if(DefinesList.addEventListener ) {
			DefinesList.addEventListener('keydown',this.keyHandler_Tab,false);
		} else if(DefinesList.attachEvent ) {
			DefinesList.attachEvent('onkeydown',this.keyHandler_Tab);
		}
		var EmptyRAMList = document.getElementById("ListOfUnusedRam");
		if(EmptyRAMList.addEventListener ) {
			EmptyRAMList.addEventListener('keydown',this.keyHandler_Tab,false);
		} else if(EmptyRAMList.attachEvent ) {
			EmptyRAMList.attachEvent('onkeydown',this.keyHandler_Tab);
		}
	}

	function keyHandler_Tab(e) {

		var target;
		if (!e) var e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				var startPos = target.selectionStart;
				var endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				MainCode()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	
	function MainCode() {
		document.getElementById("Output_AssignedRAMs").hidden = true
		let OutputString = ""
		//ListOfDefines[Index]:
		//ListOfDefines[Index][0]: String
		//ListOfDefines[Index][2]: line number
		let ListOfDefines = new Array()
		for (let Index = 0; Index < document.getElementById("ListOfFreeramDefines").value.split("\n").length; Index++) {
			ListOfDefines.push([document.getElementById("ListOfFreeramDefines").value.split("\n")[Index], Index])
		}
		//Remove lines that contain useless data
			ListOfDefines = RemoveBlankCommentOrSpacesEntry(ListOfDefines)
		//Verify all lines valid
			let DefinesLinesValid = true
			for (let Index = 0; (Index < ListOfDefines.length&&DefinesLinesValid); Index++) {
				if (!(RegExp("^" + String2Regex_GetASMResourceName + "\\t" + String2Regex_GetRAMDefine + "\\t" + String2Regex_GetNumberOfBytes + "\\t" + String2Regex_GetOptionalHexAddress + "\\t" + String2Regex_GetOptionalHexAddress + "$").test(ListOfDefines[Index][0]))) {
					DefinesLinesValid = false
				}
			}
			if (DefinesLinesValid) {
				//Parse data
					//ListOfParsedDefinesData[Index]:
					//ListOfParsedDefinesData[Index][0]: Resource name
					//ListOfParsedDefinesData[Index][1]: Define
					//ListOfParsedDefinesData[Index][2]: Size/number of bytes
					//ListOfParsedDefinesData[Index][3]: Minimum address. -1n = not specified
					//ListOfParsedDefinesData[Index][4]: Maximum address (last byte of freeram not to exceed this). -1n = not specified
					//ListOfParsedDefinesData[Index][5]: Line number extracted from. Used when invalid number of bytes were given, or if the max address is less than the min address
					//ListOfParsedDefinesData[Index][6]: Invalid number of bytes/min and max value flag. If 0 bytes on size, or both min and max supplied but max being <= min, this is true, otherwise false.
					//ListOfParsedDefinesData[Index][7]: Starting address to use, initially -1n, but will later, if it finds a space, will be a non-negative number.
					let ListOfParsedDefinesData = new Array()
					for (let Index = 0; Index < ListOfDefines.length; Index++) {
						//Resource
							let ResourceName = ListOfDefines[Index][0].match(RegExp(String2Regex_GetASMResourceName))[0]
						//Define
							let Define = ListOfDefines[Index][0].match(RegExp("(?<=" + String2Regex_GetASMResourceName + "\\t)" + String2Regex_GetRAMDefine))[0]
						//Number of bytes
							let NumberOfBytes = ParseBigIntValue(ListOfDefines[Index][0].match(RegExp("(?<=" + String2Regex_GetASMResourceName + "\\t" + String2Regex_GetRAMDefine + "\\t)" + String2Regex_GetNumberOfBytes))[0], 10)
						//Min address
							let MinAddress_String = ListOfDefines[Index][0].match(RegExp("(?<=" + String2Regex_GetASMResourceName + "\\t" + String2Regex_GetRAMDefine + "\\t" + String2Regex_GetNumberOfBytes + "\\t)" + String2Regex_GetOptionalHexAddress))[0]
							let MinAddress_BigInt = -1n
							if (MinAddress_String != "-") {
								MinAddress_BigInt = ParseBigIntValue(MinAddress_String.replace(/^\$/, ""), 16)
							}
						//Max address
							let MaxAddress_String = ListOfDefines[Index][0].match(RegExp("(?<=" + String2Regex_GetASMResourceName + "\\t" + String2Regex_GetRAMDefine + "\\t" + String2Regex_GetNumberOfBytes + "\\t" + String2Regex_GetOptionalHexAddress + "\\t)" + String2Regex_GetOptionalHexAddress))[0]
							let MaxAddress_BigInt = -1n
							if (MaxAddress_String != "-") {
								MaxAddress_BigInt = ParseBigIntValue(MaxAddress_String.replace(/^\$/, ""), 16)
							}
						//Done
							ListOfParsedDefinesData.push([ResourceName, Define, NumberOfBytes, MinAddress_BigInt, MaxAddress_BigInt, ListOfDefines[Index][1], false, -1n])
					}
				//Verify number of bytes, min and max being correct
					let NumberOfBytesAndMinMaxIsValidOnAll = true
					for (let Index = 0; Index < ListOfParsedDefinesData.length; Index++) {
						if (ListOfParsedDefinesData[Index][2] < 1n) {
							NumberOfBytesAndMinMaxIsValidOnAll = false
							ListOfParsedDefinesData[Index][6] = true
						}
						if (ListOfParsedDefinesData[Index][3] != -1n && ListOfParsedDefinesData[Index][4] != -1n) {
							if (ListOfParsedDefinesData[Index][4] <= ListOfParsedDefinesData[Index][3]) {
								NumberOfBytesAndMinMaxIsValidOnAll = false
								ListOfParsedDefinesData[Index][6] = true
							}
						}
					}
					if (NumberOfBytesAndMinMaxIsValidOnAll) {
						//Now lets process the list of empty RAMs
							let ListOfOpenRAMs = new Array()
							for (let Index = 0; Index < document.getElementById("ListOfUnusedRam").value.split("\n").length; Index++) {
								ListOfOpenRAMs.push([document.getElementById("ListOfUnusedRam").value.split("\n")[Index], Index])
							}
							//ListOfOpenRAMs[Index]:
							//ListOfOpenRAMs[Index][0]: String
							//ListOfOpenRAMs[Index][1]: line number
							//Remove useless data
								ListOfOpenRAMs = RemoveBlankCommentOrSpacesEntry(ListOfOpenRAMs)
							//Verify lines
								let EmptyRamsValid = true
								for (let Index = 0; (Index < ListOfOpenRAMs.length&&EmptyRamsValid); Index++) {
									if (!(RegExp("^" + String2Regex_GetEmptyRAM_Address + "\\t" + String2Regex_GetNumberOfBytesOrEnding + "($|\\s)").test(ListOfOpenRAMs[Index][0]))) {
										EmptyRamsValid = false
									}
								}
								if (EmptyRamsValid) {
									//Process it
										let ListOfProcessedEmptyRams = new Array()
										for (let Index = 0; Index < ListOfOpenRAMs.length; Index++) {
											let EmptyRam_StartAddress = BigInt("0x" + ListOfOpenRAMs[Index][0].match("(?<=^\\$?)[A-Fa-f\\d]+")[0])
											let NumberOfBytesOrEndAddress_String = ListOfOpenRAMs[Index][0].match(RegExp("(?<=" + String2Regex_GetEmptyRAM_Address + "\\t)" + String2Regex_GetNumberOfBytesOrEnding))[0]
											let NumberOfBytes = 0n
											if ((/^\d+$/).test(NumberOfBytesOrEndAddress_String)) {
												NumberOfBytes = BigInt(NumberOfBytesOrEndAddress_String)
											} else {
												let EndingAddressString = NumberOfBytesOrEndAddress_String.replace(/-\$?/, "")
												NumberOfBytes = BigInt("0x" + EndingAddressString) - EmptyRam_StartAddress + 1n
											}
											ListOfProcessedEmptyRams.push([EmptyRam_StartAddress, NumberOfBytes, ListOfOpenRAMs[Index][1], []])
										}
										//ListOfProcessedEmptyRams[Index]:
										//ListOfProcessedEmptyRams[Index][0]: Starting address
										//ListOfProcessedEmptyRams[Index][1]: Number of bytes
										//ListOfProcessedEmptyRams[Index][2]: Original line number
										//ListOfProcessedEmptyRams[Index][3]: array containing a list of other item's index it overlaps with, if none, then array is 0-length
										let IsAllEmptyRamsHaveValidByteSize = true
										for (let Index = 0; (Index < ListOfProcessedEmptyRams.length&&IsAllEmptyRamsHaveValidByteSize); Index++) {
											if (ListOfProcessedEmptyRams[Index][1] < 1n) {
												IsAllEmptyRamsHaveValidByteSize = false
											}
										}
										if (IsAllEmptyRamsHaveValidByteSize) {
											//If byte size or end address is valid, now check if any are overlapping
												let IsEmptyRAMsNotOverlapping = true
												for (let Index = 0; Index < ListOfProcessedEmptyRams.length; Index++) {
													for (let Index2 = Index + 1; Index2 < ListOfProcessedEmptyRams.length; Index2++) {
														if (CheckOverlap(ListOfProcessedEmptyRams[Index][0], ListOfProcessedEmptyRams[Index][0] + ListOfProcessedEmptyRams[Index][1] -1n, ListOfProcessedEmptyRams[Index2][0], ListOfProcessedEmptyRams[Index2][0] + ListOfProcessedEmptyRams[Index2][1] -1n)) {
															IsEmptyRAMsNotOverlapping = false
															ListOfProcessedEmptyRams[Index][3].push(Index2)
															ListOfProcessedEmptyRams[Index2][3].push(Index)
														}
													}
												}
												if (IsEmptyRAMsNotOverlapping) {
													//Sort, this makes it consistent that bytes will be used from low to high addresses when one define have multiple suitable ranges.
														ListOfProcessedEmptyRams.sort(SortByStartAddr)
													//Now we assign each define.
													//ListOfParsedDefinesData[Index]:
													//ListOfParsedDefinesData[Index][0]: Resource name
													//ListOfParsedDefinesData[Index][1]: Define
													//ListOfParsedDefinesData[Index][2]: Size/number of bytes
													//ListOfParsedDefinesData[Index][3]: Minimum address. -1n = not specified
													//ListOfParsedDefinesData[Index][4]: Maximum address (last byte of freeram not to exceed this). -1n = not specified
													//ListOfParsedDefinesData[Index][5]: Line number extracted from. Used when invalid number of bytes were given, or if the max address is less than the min address
													//ListOfParsedDefinesData[Index][6]: Invalid number of bytes/min and max value flag. If 0 bytes on size, or both min and max supplied but max being <= min, this is true, otherwise false.
													//ListOfParsedDefinesData[Index][7]: Starting address to use, initially -1n, but will later, if it finds a space, will be a non-negative number.
													//ListOfProcessedEmptyRams[Index2]:
													//ListOfProcessedEmptyRams[Index2][0]: Starting address
													//ListOfProcessedEmptyRams[Index2][1]: Number of bytes
													//ListOfProcessedEmptyRams[Index2][2]: Original line number
													//ListOfProcessedEmptyRams[Index2][3]: array containing a list of other item's index it overlaps with, if none, then array is 0-length
														for (let Index = 0; Index < ListOfParsedDefinesData.length; Index++) {
															let IsPlacedUsageSuccessful = false
															for (let Index2 = 0; (Index2 < ListOfProcessedEmptyRams.length&&IsPlacedUsageSuccessful == false); Index2++) {
																let StartPos = ListOfProcessedEmptyRams[Index2][0]
																if (ListOfParsedDefinesData[Index][3] != -1n&& StartPos < ListOfParsedDefinesData[Index][3]) {
																	StartPos = ListOfParsedDefinesData[Index][3]
																}
																let EndPos = ListOfProcessedEmptyRams[Index2][0] + ListOfProcessedEmptyRams[Index2][1] -1n
																if (ListOfParsedDefinesData[Index][4] != -1n&& EndPos > ListOfParsedDefinesData[Index][4]) {
																	EndPos = ListOfParsedDefinesData[Index][4]
																}
																let SizeAvailableSpace = EndPos - StartPos +1n
																if (ListOfParsedDefinesData[Index][2] <= SizeAvailableSpace) { //If this can fit...
																	ListOfParsedDefinesData[Index][7] = StartPos
																	IsPlacedUsageSuccessful = true
																	//modify the empty RAM array. This can potentially split the RAM range into 2 ranges.
																		//First, find if there will be empty RAM between ListOfProcessedEmptyRams[Index2][0] and StartPos
																			let SplittedRamBeforeStart = [ListOfProcessedEmptyRams[Index2][0], StartPos - ListOfProcessedEmptyRams[Index2][0]]
																		//Second, find if there will be empty RAM between ListOfParsedDefinesData[Index][7] + ListOfParsedDefinesData[Index][2] and
																		//ListOfProcessedEmptyRams[Index2][0] + ListOfProcessedEmptyRams[Index2][1] -1n
																			let SplittedRamAfterEnd = [ListOfParsedDefinesData[Index][7] + ListOfParsedDefinesData[Index][2], ListOfProcessedEmptyRams[Index2][0] + ListOfProcessedEmptyRams[Index2][1] -1n - (ListOfParsedDefinesData[Index][7] + ListOfParsedDefinesData[Index][2] - 1n)]
																		//and now we want to modify this range since we placed our usage there.
																			if (SplittedRamBeforeStart[1] < 1n && SplittedRamAfterEnd[1] < 1n) { //if the start and end of usage used the entire range...
																				ListOfProcessedEmptyRams.splice(Index2, 1)
																			} else if (SplittedRamBeforeStart[1] >= 1n && SplittedRamAfterEnd[1] < 1n) { //if the start of usage had a gap before it but no gaps after the end of usage...
																				ListOfProcessedEmptyRams.splice(Index2, 1, SplittedRamBeforeStart)
																			} else if (SplittedRamBeforeStart[1] < 1n && SplittedRamAfterEnd[1] >= 1n) { //if the start of usage had no gap before it, but a gap after the end
																				ListOfProcessedEmptyRams.splice(Index2, 1, SplittedRamAfterEnd)
																			} else if (SplittedRamBeforeStart[1] >= 1n && SplittedRamAfterEnd[1] >= 1n) { //if both before the start of usage and after the end of usage had a gap, the range is split into 2.
																				ListOfProcessedEmptyRams.splice(Index2, 1, SplittedRamBeforeStart, SplittedRamAfterEnd)
																			}
																}
															}
														}
														let Statistics_RAMAssign_Success = 0
														let Statistics_RAMAssign_Failed = 0
														for (let Index = 0; Index < ListOfParsedDefinesData.length; Index++) {
															if (ListOfParsedDefinesData[Index][7] != -1n) {
																Statistics_RAMAssign_Success++
															} else {
																Statistics_RAMAssign_Failed++
															}
														}
														//Sorter
															if (document.getElementById("Sort_ByResourceName").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_ResourceName)
															} else if (document.getElementById("Sort_ByResourceName_Reverse").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_ResourceName_Rev)
															} else if (document.getElementById("Sort_ByAddress").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_AssignedAddress)
															} else if (document.getElementById("Sort_ByAddress_Reverse").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_AssignedAddress_Rev)
															} else if (document.getElementById("Sort_BySize").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_Size)
															} else if (document.getElementById("Sort_BySize_Reverse").checked) {
																ListOfParsedDefinesData.sort(Func_Sort_Size_Rev)
															}
														//Output
															ListOfProcessedEmptyRams.sort()
															OutputString += "Total defines: " + BigInt(ListOfParsedDefinesData.length).toString(10) + "\n"
															OutputString += "Defines that were successfully placed: " + BigInt(Statistics_RAMAssign_Success).toString(10) + "\n"
															OutputString += "Defines that failed to be placed: " + BigInt(Statistics_RAMAssign_Failed).toString(10) + "\n"
															OutputString += "----------------------------------------------------------------------------------------\n"
															for (let Index = 0; Index < ListOfParsedDefinesData.length; Index++) {
																if (ListOfParsedDefinesData[Index][7] != -1n) {
																	OutputString += ListOfParsedDefinesData[Index][1] + " = $" + ListOfParsedDefinesData[Index][7].toString(16).toUpperCase() + " ;>" + ListOfParsedDefinesData[Index][0] + ", " + ListOfParsedDefinesData[Index][2].toString(10) + " byte(s)"
																} else {
																	OutputString += ListOfParsedDefinesData[Index][1] + " = No sufficent space found. (" + ListOfParsedDefinesData[Index][0] + ", " + ListOfParsedDefinesData[Index][2].toString(10) + " byte(s))"
																}
																OutputString += "\n"
															}
												} else {
													let ListOfOverlappingEmptyRams = new Array()
													for (let Index = 0; Index < ListOfProcessedEmptyRams.length; Index++) {
														if (ListOfProcessedEmptyRams[Index][3].length > 0) {
															ListOfOverlappingEmptyRams.push(ListOfProcessedEmptyRams[Index])
														}
													}
													OutputString += "Error: The list of empty RAMs have overlapped with another:\n"
													for (let Index = 0; Index < ListOfOverlappingEmptyRams.length; Index++) {
														OutputString += "ListOfOpenRAMs_Line " + BigInt(ListOfProcessedEmptyRams[Index][2] + 1).toString(10) + ": Address $" + ListOfProcessedEmptyRams[Index][0].toString(16).toUpperCase() + ", " + ListOfProcessedEmptyRams[Index][1].toString(10) + " byte(s) (ends: $" + (ListOfProcessedEmptyRams[Index][0] + ListOfProcessedEmptyRams[Index][1] -1n).toString(16).toUpperCase() + "). "
														OutputString += "Line number(s) it conflicts with: "
														for (let Index2 = 0; Index2 < ListOfProcessedEmptyRams[Index][3].length; Index2++) {
															OutputString += BigInt(ListOfOverlappingEmptyRams[ListOfOverlappingEmptyRams[Index][3][Index2]][2] + 1).toString(10)
															if (Index2 != ListOfProcessedEmptyRams[Index][3].length -1) {
																OutputString += ", "
															}
														}
														if (Index != ListOfOverlappingEmptyRams.length -1) {
															OutputString += "\n"
														}
													}
												}
										} else {
											let ListOfEmptyRamsWithWrongBytes = new Array()
											for (let Index = 0; Index < ListOfProcessedEmptyRams.length; Index++) {
												if (ListOfProcessedEmptyRams[Index][1] < 1n) {
													ListOfEmptyRamsWithWrongBytes.push(ListOfProcessedEmptyRams[Index])
												}
											}
											OutputString += "Error: The list of empty RAMs have incorrect number of bytes or ending address lower than the start address:\n"
											for (let Index = 0; Index < ListOfEmptyRamsWithWrongBytes.length; Index++) {
												OutputString += "ListOfOpenRAMs_Line " + BigInt(ListOfProcessedEmptyRams[Index][2] + 1).toString(10) + ": Address $" + ListOfProcessedEmptyRams[Index][0].toString(16).toUpperCase()
												if (Index != ListOfEmptyRamsWithWrongBytes.length -1) {
													OutputString += "\n"
												}
											}
										}
								} else {
									let ListOfInvalidLines_OpenRams = new Array()
									for (let Index = 0; Index < ListOfOpenRAMs.length; Index++) {
										if (!(RegExp("^" + String2Regex_GetEmptyRAM_Address + "\\t" + String2Regex_GetNumberOfBytesOrEnding + "($|\\s)").test(ListOfOpenRAMs[Index][0]))) {
											ListOfInvalidLines_OpenRams.push(ListOfOpenRAMs[Index])
										}
									}
									OutputString += "Error: The list of empty RAMs have invalid information:\n"
									for (let Index = 0; Index < ListOfInvalidLines_OpenRams.length; Index++) {
										OutputString += "ListOfOpenRAMs_Line " + BigInt(ListOfInvalidLines_OpenRams[Index][1] + 1).toString(10) + ": [" + ListOfInvalidLines_OpenRams[Index][0] + "]"
										if (Index != ListOfInvalidLines_OpenRams.length -1) {
											OutputString += "\n"
										}
									}
								}
					} else {
						let ListOfInvalidBytesOrRange = new Array()
						for (let Index = 0; Index < ListOfParsedDefinesData.length; Index++) {
							if (ListOfParsedDefinesData[Index][6]) {
								ListOfInvalidBytesOrRange.push(ListOfParsedDefinesData[Index])
							}
						}
						OutputString += "Error: The list of freeram defines have invalid number of bytes or have max address lower than or equal to min:\n"
						for (let Index = 0; Index < ListOfInvalidBytesOrRange.length; Index++) {
							OutputString += "ListOfDefines_Line " + BigInt(ListOfInvalidBytesOrRange[Index][5] + 1).toString(10) + ": [" + ListOfInvalidBytesOrRange[Index][0] + "\t" + ListOfInvalidBytesOrRange[Index][1] + "\t" + ListOfInvalidBytesOrRange[Index][2] + "\t"
							if (ListOfInvalidBytesOrRange[Index][3] != -1n) {
								OutputString += "$" + ListOfInvalidBytesOrRange[Index][3].toString(16).toUpperCase()
							} else {
								OutputString += "NoMinProvided"
							}
							OutputString += "\t"
							if (ListOfInvalidBytesOrRange[Index][4] != -1n) {
								OutputString += "$" + ListOfInvalidBytesOrRange[Index][4].toString(16).toUpperCase()
							} else {
								OutputString += "NoMaxProvided"
							}
							OutputString += "]"
							if (Index != ListOfInvalidBytesOrRange.length -1) {
								OutputString += "\n"
							}
						}
					}
			} else {
				let ListOfInvalidLines = new Array()
				for (let Index = 0; Index < ListOfDefines.length; Index++) {
					if (!(RegExp("^" + String2Regex_GetASMResourceName + "\\t" + String2Regex_GetRAMDefine + "\\t" + String2Regex_GetNumberOfBytes + "\\t" + String2Regex_GetOptionalHexAddress + "\\t" + String2Regex_GetOptionalHexAddress + "$").test(ListOfDefines[Index][0]))) {
						ListOfInvalidLines.push(ListOfDefines[Index])
					}
				}
				OutputString += "Error: The list of freeram defines have invalid information:\n"
				for (let Index = 0; Index < ListOfInvalidLines.length; Index++) {
					OutputString += "ListOfDefines_Line " + BigInt(ListOfInvalidLines[Index][1] + 1).toString(10) + ": [" + ListOfInvalidLines[Index][0] + "]"
					if (Index != ListOfInvalidLines.length -1) {
						OutputString += "\n"
					}
				}
			}
		document.getElementById("Output_AssignedRAMs").hidden = false
		document.getElementById("Output_AssignedRAMs").value = OutputString
	}
	//Other functions
		//Remove stuff that is not address data
			function RemoveBlankCommentOrSpacesEntry(InputArray) {
				let OutputArray = new Array()
				for (let index1 = 0; index1 < InputArray.length; index1++) {
					if ((/^(\s*)$|^()$|^(\s*;+.*)$/).test(InputArray[index1][0]) == false) {
						OutputArray.push(InputArray[index1])
					}
				}
				return OutputArray
			}
		function ParseBigIntValue(string, radix) {
			//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
			//this works with bigInt.
			let Output = 0n
			let NegativeNumber = 1n
			if ((/^-/).test(string)) {
				NegativeNumber = -1n
			}
			let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
			switch (radix) {
				//decimal
					default:
					if ((/^-?\d+$/).test(string)) {
						Output = BigInt(string)
					}
					break
				//Hexadecimal
					case 16:
					case "0x":
					case "0X":
					if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
						Output = BigInt("0x" + DigitPart) * NegativeNumber
					}
					break
				//Binary
					case 2:
					case "0b":
					case "0B":
					if ((/^-?[01]+$/).test(string)) {
						Output = BigInt("0b" + DigitPart) * NegativeNumber
					}
			
			}
			return Output
		}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	//Sort (for empty RAM)
		function SortByStartAddr(a, b) {
			if (a[0] === b[0]) {
				return 0;
			} else {
				return (a[0] < b[0]) ? -1 : 1;
			}
		}
	//Output-based sort
		function Func_Sort_ResourceName(a, b) {
			if (a[0] === b[0]) {
				return 0;
			} else {
				return (a[0] < b[0]) ? -1 : 1;
			}
		}
		function Func_Sort_ResourceName_Rev(a, b) {
			if (a[0] === b[0]) {
				return 0;
			} else {
				return (a[0] < b[0]) ? 1 : -1;
			}
		}
		function Func_Sort_AssignedAddress(a, b) {
			if (a[7] === b[7]) {
				return 0;
			} else {
				return (a[7] < b[7]) ? -1 : 1;
			}
		}
		function Func_Sort_AssignedAddress_Rev(a, b) {
			if (a[7] === b[7]) {
				return 0;
			} else {
				return (a[7] < b[7]) ? -1 : 1;
			}
		}
		function Func_Sort_Size(a, b) {
			if (a[2] === b[2]) {
				return 0;
			} else {
				return (a[2] < b[2]) ? -1 : 1;
			}
		}
		function Func_Sort_Size_Rev(a, b) {
			if (a[2] === b[2]) {
				return 0;
			} else {
				return (a[2] < b[2]) ? -1 : 1;
			}
		}
</script>