<html>
	<head>
		<style>
			html {
			background-color: rgb(29, 30, 38);
			color: rgb(221, 221, 221);
			font-family: sans-serif;
			}
			
			ul {
			line-height: 150%;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			select, option {
				font-family: monospace;
			}
			
			textarea {
				white-space: pre;
				overflow-wrap: normal;
				overflow-x: scroll;
			}
			
			td.StatisticTableCell {
				font-family: monospace;
				min-width: 50px;
				text-align: end;
			}
			summary {
				border: 1px solid white;
				background-color: #707070;
				cursor: pointer;
			}
			pre {
				margin: 0px;
			}
			div.CodeBlock {
				overflow: auto;
				width: 700px;
				height: 100px;
				border: 1px solid white;
				resize: both;
				background-color: #101010;
			}
		</style>
	</head>
<body style="max-width: 720px; margin: auto; padding: 15px">
<p><a href="HowToUse.html#From_Addresser" id="From_HowToUse">How to use</a></p>
<p><a href="Assigner.html#From_Addresser" id="From_Assigner">Assigner tool</a></p>

<p>Enter a list of RAM or any memory usage in the textarea below. Must be formatted like this:
<table><tr><td><pre>Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description</pre></td></tr></table><br>
Data is seperated with a single space or tab character.
</p>
<details>
<summary>Syntax and formatting notes</summary>
	Formatting notes:
	<ul>
		<li>Lines that are blank or composed of just any whitespace characters are ignored. It will also ignore any lines that start with either a semicolon or a space (0 or more), followed by a semicolon (therefore ASM-styled comments are allowed).</li>
		<li>This does not take in account of addressing mirroring (a shorthand <kbd>$00</kbd> instead of <kbd>$7E0000</kbd>), so I strongly recommend putting the full address numbers here. Furthermore, it does not detect what type of memory map it is,
		things like negative address (only shown on &ldquo;<kbd>Potential ending address before the starting byte of all the ranges</kbd>&rdquo;), address pointing beyond the last byte of the entire memory map, and so on.</li>
		<li>This tool could be applied to other systems (beyond the SNES), since it merely check ranges.</li>
	</ul>
	Where:
	<ul>
		<li><kbd>Address</kbd> is the starting address, in hex. <kbd>$</kbd> prefix is optional.</li>
		<li><kbd>Size_in_bytes_Or_EndAddress</kbd> can either be the number of bytes starting from <kbd>Address</kbd> and ending at <kbd>Address + Size_in_bytes - 1</kbd> or the ending address:
			<ul>
				<li><kbd>Decimal_Number</kbd> - number of bytes, in decimal. Don't use commas to separate digit grouping.</li>
				<li><kbd>~Hexidecimal_EndAddress</kbd> - the ending address (note the tilde to denote a range), in hex. Also <kbd>$</kbd> prefix is optional (must be placed after
				the tilde and before the hexadecimal address number (example: <kbd>$~10</kbd> is wrong, <kbd>~$10</kbd> is correct)).</li>
			</ul>
		</li>
		<li><kbd>Description</kbd> (optional) is a brief description.</li>
	</ul>
</details>
<div>
	<div><label><input type="radio" name="InputSetting" id="InputSetting_UploadTxt" onchange="HideInputSetting();" checked>Upload text file</label></div>
	<div><label><input type="radio" name="InputSetting" id="InputSetting_PasteText" onchange="HideInputSetting();">Paste text</label></div>
</div><br><br>
<div>
	<div id="Input_UploadTxt">
		<input type="file" id="UserInputTxtFile" accept=".txt,.asm" onchange="ProcessFile();">
		<div hidden style="color: #800000;" id="InvalidFileMsg">Error reading file.</div>
		<div hidden style="color: #008000;" id="SuccessReadMsg">File read successful.</div>
		<div hidden id="FileProcessingDisplay">
			<div id="ProgressText"></div>
			<div id="ProgressBar" style="width: 400px; height: 5px; border: 1px solid #FFFFFF;"></div>
		</div>
	</div>
	<div id="Input_PasteText" hidden>
		<button onclick="ClearInputList()">Clear</button><button onclick="AutoEnterSMWInput()">Reset textarea</button><br>
		<textarea id="UserInputList" cols="75" rows="30" oninput="MainCodeWithFullRefresh()" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
	</div>
</div><br><br>
<div>
	<abbr title="This will take the starting (and ending address) you entered above, add (offsets) by this value, and the output are the off-set by this. Useful if you using RAM mirrors - like this: $01 becomes $7E0001 by an offset of $7E0000.">Offset input addresses by</abbr>: <input type="number" id="AddressOffsetterDec" onchange="AddressOffsetterDec_DecToHex()" value="0" step="1">($<input type="text" value="0" class="HexNumberInput" onchange="AddressOffsetterDec_HexToDec()" id="AddressOffsetterHex">)<br>
	View mode:
	<div><label><input type="radio" name="Setting_ViewMode" onchange="AdjustMode()" id="Setting_ViewMode_Table" checked>Table range</label></div>
	<div><label><input type="radio" name="Setting_ViewMode" onchange="AdjustMode()" id="Setting_ViewMode_Byte">Byte view</label></div>
</div>
<div>
	Other:
	<div>
		<label><input type="checkbox" id="Setting_IgnoreDupes" onchange="MainCodeWithFullRefresh()" checked>Ignore duplicates</label>
	</div>
</div>
<hr>
<div id="SettingPanel_TableViewOptions">
	Sort: <select onchange="MainCode()">
		<option id="SortOption_None">Keep order you entered</option>
		<option id="SortOption_ByAddr" selected>By start address</option>
		<option id="SortOption_Size">By size</option>
		<option id="SortOption_Discription">By description (lexicographically)</option>
		<option id="SortOption_Type">By type</option>
		<option id="SortOption_OverlapCount">By overlap count</option>
	</select><label><input type="checkbox" id="SortOption_Reverse" onchange="MainCode()">Reverse order</label><br><br>
	<div>Filter by: <button onclick="ModifyCheckboxes(this.parentNode, 1); MainCode();">Check all</button><button onclick="ModifyCheckboxes(this.parentNode, 0); MainCode();">Uncheck all</button><button onclick="ModifyCheckboxes(this.parentNode, 2); MainCode();">Invert</button>
		<div><label><input type="checkbox" onchange="MainCode()" checked id="Filter_Gap">Unused gaps</label></div>
		<div><label><input type="checkbox" onchange="MainCode()" checked id="Filter_NonOverlap">Address with no conflicts</label></div>
		<div><label><input type="checkbox" onchange="MainCode()" checked id="Filter_Overlap">Address that conflicted</label></div>
	</div><br><br>
	<div>
		Plaintext size/ending address mode display: <select onchange="MainCode();">
			<option id="PlaintextSetting_Output_Size">Size</option>
			<option id="PlaintextSetting_Output_Ending">Ending</option>
			<option id="PlaintextSetting_Output_SizeAndEnding">Size and ending (&lt;size&gt;/-&lt;ending_address&gt;)</option>
		</select>
	</div>
	<div>
		<label><input type="checkbox" id="PlaintextSetting_Output_OverlapStatus" checked onchange="MainCode()">Show gap/overlap/non-overlap status</label>
	</div>
</div>
<div id="SettingPanel_ByteViewOptions" hidden>
	Address to view: $<input type="text" value="0" class="HexNumberInput" id="SVGAddressView" onchange="MainCode()"><br>
	Useful tips using this feature:
	<ul>
	<li>Hover your mouse over the display and roll your scroll wheel to scroll the graph. Alternatively up/down arrow keys will work.</li>
	<li>To scroll by an entire screen, hold CTRL and roll your scroll wheel. You can also do this by clicking on the graph and press page up/down.</li>
	<li>You can also scroll horizontally, by holding SHIFT and rolling the scroll wheel. Alternatively left/right arrow keys will work.</li>
	</ul>
</div>
<hr>
<div hidden id="Output_ErrorMessageDiv" style="border: 1px solid white; overflow: auto; resize: both" class="CodeBlock">
	<pre id="Output_ErrorMessage"></pre>
</div>
<div id="Output_AddressInfo">
	<table>
		<tr><th colspan="2">Address statistics</th></tr>
		<tr><td style="font-family: monospace; background-color: #008000">Number of entered ranges that didn&apos;t overlap</td><td class="StatisticTableCell" id="OutputStatistics_NonOverlap">0</td></tr>
		<tr><td style="font-family: monospace; background-color: #800000">Number of entered ranges that overlap</td><td class="StatisticTableCell" id="OutputStatistics_Overlap">0</td></tr>
		<tr><td style="font-family: monospace; background-color: #808080">Number of gap ranges found</td><td class="StatisticTableCell" id="OutputStatistics_Gaps">0</td></tr>
		<tr><td style="font-family: monospace;">Total ranges including gaps</td><td class="StatisticTableCell" id="OutputStatistics_TotalIncludingGaps">0</td></tr>
		<tr><td style="font-family: monospace;">Lowest used address</td><td class="StatisticTableCell" id="OutputStatistics_UsedAddress_Min"></td></tr>
		<tr><td style="font-family: monospace;">Highest used address</td><td class="StatisticTableCell" id="OutputStatistics_UsedAddress_Max"></td></tr>
		<tr>
			<td style="font-family: monospace;">Number of bytes between the lowest and highest used addresses</td>
			<td class="StatisticTableCell" id="OutputStatistics_TotalBytes_BetweenMinMax"></td>
		</tr>
		<tr>
			<td style="font-family: monospace; background-color: #008000;">Non-overlaps total bytes</td>
			<td class="StatisticTableCell" id="OutputStatistics_TotalBytes_NonOverlaps">0</td>
		</tr>
		<tr>
			<td style="font-family: monospace; background-color: #808080">Gaps total bytes</td>
			<td class="StatisticTableCell" id="OutputStatistics_TotalBytes_Gaps">0</td>
		</tr>
		
	</table>
	<hr>
	<div id="ViewMode_TextTable">
		<div style="font-family: monospace;">Number of results (after filter): <span id="OutputStatistics_TotalAfterFilter">0</span></div>
		<textarea id="Output_AddressInfo_Text" readonly cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: white"></textarea><br>
			<div>
				<button onclick="setClipboard(document.getElementById('Output_AddressInfo_Text').value);">Copy to clipboard</button>
				<span></span>
			</div><br>
			<div>
				<button onclick="CopyGaps()" disabled id="Button_QuickCopyGaps">Quick-copy gaps</button>
				<span></span>
				<span id="QuickCopyGapsExistMsg" style="color: #FF0000">No gap exists!</span>
			</div><br>
		<div style="overflow: auto; height: 500px; min-height: 500px; min-width: 700px; border: 1px solid white; resize: both;">
			<table id="Output_AddressInfo_Table"></table>
		</div><div style="height: 300px;" !-- This is to make the resizable DIV element above easily resizable and prevent scrol-jumping when page size changes --></div>
	</div>
	<div id="ViewMode_AddressBytes" hidden>
		<button onclick="ResetSVGHorizScoll()" id="Btn_ResetHorizScroll">Reset horizontal scroll</button><br>
		<svg id="SVGGraph" style="width: 400px; height: 700px; border: 1px solid white" tabindex="0"></svg>
	</div>
</div>
<script>
	//Note to users updating my addresser tool: If you are planning to modify RAM info text that would be freed up by patches,
	//to find that data, just CTRL+F "SMWUsedRAMText" without quotes.

	const Setting_ByteView_SVGGridSizeFactor = 16n
	const Setting_ByteView_AddressColumnPosition = 5n		//Note: right-aligned, from text-anchor, position of the right edge of text
	const Setting_ByteView_BarsXPosStart = 5n			//Note: left-aligned, position from left edge.
	const Setting_ByteView_NumberOfRows = 100n
	const Setting_ByteView_NumberOfColumns = 20n			//Width of viewbox, that, multiplied by Setting_ByteView_SVGGridSizeFactor
	
	let SavedAddresses = []
	let HaveEditedTextarea = false
	let NeedsToUpdateSVGOrder = false
	let SavedSortedForSVGOrder = []
	let UsedAddress_Min = Infinity
	let UsedAddress_Max = -Infinity
	let SVGHorizontalScroll = 0n
	let GapList = []
	
	let ColorCodedStatus = {
		"NonOverlap" : "#008000",
		"Overlap" : "#800000",
		"Gap": "#808080"
	}
	let SVG_GraphElement = document.getElementById("SVGGraph")
	let CopiedMessage = document.getElementById("CopiedMessage")
	AddHexIncrementDecrementToTextInputs()
	document.getElementById("UserInputList").addEventListener("keydown", this.keyHandler_Tab, false)
	SVG_GraphElement.addEventListener(
		"wheel",
		function (e) {
			e.preventDefault()
			if (!e.shiftKey) {
				let AddressView = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
				let ScrollSize = 4n
				if (e.ctrlKey) {
					ScrollSize = Setting_ByteView_NumberOfRows
				}
				if (e.deltaY > 0) {
					AddressView = AddressView+ScrollSize
				} else if (e.deltaY < 0) {
					AddressView = AddressView-ScrollSize
				}
				document.getElementById("SVGAddressView").value = AddressView.toString(16).toUpperCase()
			} else {
				let ScrollSize = 1n
				if (e.deltaY > 0) {
					SVGHorizontalScroll = SVGHorizontalScroll+ScrollSize
				} else if (e.deltaY < 0) {
					SVGHorizontalScroll = SVGHorizontalScroll-ScrollSize
				}
			}
			MainCode()
		}
	
	)
	SVG_GraphElement.addEventListener(
		"keydown",
		function (e) {
			let shouldUpdateOutput = false
			
			let InputKeyPressed = e.key
			if (InputKeyPressed == "ArrowUp"||InputKeyPressed == "ArrowDown"||InputKeyPressed == "ArrowLeft"||InputKeyPressed == "ArrowRight"||InputKeyPressed == "PageUp"||InputKeyPressed == "PageDown") {
				e.preventDefault()
				shouldUpdateOutput = true
			}
			let AddressView = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
			if (InputKeyPressed == "ArrowUp") {
				AddressView = AddressView-4n
			} else if (InputKeyPressed == "ArrowDown") {
				AddressView = AddressView+4n
			} else if (InputKeyPressed == "PageUp") {
				AddressView = AddressView-Setting_ByteView_NumberOfRows
			} else if (InputKeyPressed == "PageDown") {
				AddressView = AddressView+Setting_ByteView_NumberOfRows
			}
			if (InputKeyPressed == "ArrowLeft") {
				SVGHorizontalScroll--
			}
			if (InputKeyPressed == "ArrowRight") {
				SVGHorizontalScroll++
			}
			
			document.getElementById("SVGAddressView").value = AddressView.toString(16).toUpperCase()
			if (shouldUpdateOutput) {
				//This if statement above prevents a bug where your text selection gets canceled on keypress
				//because MainCode() will clear the output elements before writing a new output, thus
				//deleting content you've selected.
				MainCode()
			}
		}
	)
	function ResetSVGHorizScoll() {
		SVGHorizontalScroll = 0n
		MainCode()
	}
	function AddHexIncrementDecrementToTextInputs() {
		//Elements you want to apply to must contain a class "HexNumberInput"
		[...document.querySelectorAll("input.HexNumberInput")].forEach(TextInput => {
			TextInput.addEventListener(
				"keydown",
				((e) => {
					let KeyName = e.key
					if (e.altKey) {
						return
					}
					if (/(?:ArrowUp|ArrowDown)/.test(KeyName)) {
						let Str = e.target.value
						try {
							let IntegerValue = ParseBigIntValue(Str, 16)
							if (KeyName == "ArrowUp") {
								e.preventDefault()
								IntegerValue++
							} else if (KeyName == "ArrowDown") {
								e.preventDefault()
								IntegerValue--
							}
							e.target.value = IntegerValue.toString(16).toUpperCase()
							e.target.onchange()
						} catch {}
					}
				}).bind(TextInput)
			);
			TextInput.addEventListener(
				"change",
				((e) => {
					let Str = e.target.value
					let IntegerValue = ParseBigIntValue(Str, 16)
					e.target.value = IntegerValue.toString(16).toUpperCase()
					MainCode()
				})
			)
		});
	}
	function AdjustMode() {
		if (document.getElementById("Setting_ViewMode_Table").checked) {
			document.getElementById("SettingPanel_TableViewOptions").hidden = false
			document.getElementById("SettingPanel_ByteViewOptions").hidden = true
			document.getElementById("ViewMode_TextTable").hidden = false
			document.getElementById("ViewMode_AddressBytes").hidden = true
		} else if (document.getElementById("Setting_ViewMode_Byte").checked) {
			document.getElementById("SettingPanel_TableViewOptions").hidden = true
			document.getElementById("SettingPanel_ByteViewOptions").hidden = false
			document.getElementById("ViewMode_TextTable").hidden = true
			document.getElementById("ViewMode_AddressBytes").hidden = false
		}
		MainCode()
	}
	function AddressOffsetterDec_DecToHex() {
		let Offsetter = ParseBigIntValue(document.getElementById("AddressOffsetterDec").value)
		document.getElementById("AddressOffsetterDec").value = Offsetter.toString(10)
		document.getElementById("AddressOffsetterHex").value = Offsetter.toString(16).toUpperCase()
		MainCodeWithFullRefresh()
	}
	function AddressOffsetterDec_HexToDec() {
		let Offsetter = ParseBigIntValue(document.getElementById("AddressOffsetterHex").value, 16)
		document.getElementById("AddressOffsetterHex").value = Offsetter.toString(16).toUpperCase()
		document.getElementById("AddressOffsetterDec").value = Offsetter.toString(10)
		MainCodeWithFullRefresh()
	}
	function MainCodeWithFullRefresh() {
		HaveEditedTextarea = true
		NeedsToUpdateSVGOrder = true
		
		MainCode()
	}
	function HideInputSetting() {
		document.getElementById("Input_UploadTxt").hidden = !document.getElementById("InputSetting_UploadTxt").checked
		document.getElementById("Input_PasteText").hidden = document.getElementById("InputSetting_UploadTxt").checked
	}
	function ProcessFile() {
		let Files = [...event.target.files]
		let FileToProcess = Files.at(-1)
		
		let Flag_InvalidFile = (FileToProcess && FileToProcess.type !== "text/plain")
		document.getElementById("InvalidFileMsg").hidden = !Flag_InvalidFile
		if (Flag_InvalidFile) {
			return
		}
		let FileReaderText = new FileReader()
		FileReaderText.onload = function (e) {
			let TextContent = e.target.result
			document.getElementById("UserInputList").value = TextContent
			document.getElementById("SuccessReadMsg").hidden = false
			document.getElementById("InvalidFileMsg").hidden = true
			MainCodeWithFullRefresh()
			MainCode()
		}
		FileReaderText.onerror = function(e) {
			document.getElementById("UserInputList").value = ""
			document.getElementById("SuccessReadMsg").hidden = true
			document.getElementById("FileProcessingDisplay").hidden = true
			document.getElementById("InvalidFileMsg").hidden = false
		}
		FileReaderText.onprogress = (e) => {
			let Progress = e.loaded
			let ProgressEnd = e.total
			let ProgressPercentage = Progress * 100 / ProgressEnd //Multiply first so that rounding (after division) happens at the end to mitigate rounding errors
			document.getElementById("FileProcessingDisplay").hidden = false
			document.getElementById("ProgressText").textContent = "Loading: " + ProgressPercentage.toFixed(2) + "%"
			document.getElementById("ProgressBar").style.backgroundImage = CSSLinearGradientProgressBar({Quantity: Progress, MaxQuantity: ProgressEnd, ColorFull: "#0000C0"})
		}
		let TextContent = FileReaderText.readAsText(FileToProcess) //Yet to read the file
	}
	function CSSLinearGradientProgressBar({Quantity = 0, MaxQuantity = 100, Direction = "to right", ColorFull = "#C0C0C0", ColorEmpty = "rgb(29, 30, 38)"}) {
		//Returns a percentage displayed as a gradient representing a bar graph as CSS. Preferably as a background image.
		let Percentage = 0
		if (MaxQuantity != 0) {
			Percentage = Quantity * 100/MaxQuantity //Multiply first so that it only rounds at the last step, minimizing rounding errors.
		}
		Percentage = clamp(Percentage, 0, 100)
		return "linear-gradient("+Direction+", "+ColorFull+" "+Percentage.toFixed(17)+"%, "+ColorEmpty+" "+Percentage.toFixed(17)+"% 100%)"
	}
	function clamp(num, min, max) {
		//Restrict a number within a specified range.
			if (isNaN(num) == true) {
				num = 0
			}
			return num <= min ? min : num >= max ? max : num;
	}
	function MainCode() {
		ObjectOfDataRanges = []
		
		let StartingAddressViewing = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
		if (HaveEditedTextarea) {
			HaveEditedTextarea = false
			let ErrorExists = false
			let LinesOfText = document.getElementById("UserInputList").value.split('\n')
			let Offsetter = ParseBigIntValue(document.getElementById("AddressOffsetterHex").value, 16)
			
			
			UsedAddress_Min = Infinity
			UsedAddress_Max = -Infinity
			
			ObjectOfDataRanges = LinesOfText.map((Line, Index) => {
				//This converts each line entry into manageable objects.
				let SourceText = Line
				if (/^\s*(?:;.*)?$/.test(Line)) {
					return {
						Type: "CommentOrBlankLine"
					}
				}
				if (!/^\s*-?\$?[\da-fA-F]+(?:\s+)(?:\d+|\~-?\$?[\da-fA-F]+)(?:(?:\s+).*)?$/.test(Line)) {
					ErrorExists = true
					return {
						Type: "Error",
						Reason: "Invalid syntax.",
						SourceText: SourceText,
						LineNumber: Index
					}
				
				}
				let LineNoLeadingSpaces = Line.replace(/^\s*/, "")
				let LineExtracted = LineNoLeadingSpaces.match(/[^\s]+/g)
				let Description = LineNoLeadingSpaces.replace(/^[^\s]+\s[^\s]+\s?/, "")
				LineExtracted.splice(2, Infinity, Description)
				let StartAddress = ParseBigIntValue(LineExtracted[0].replace("$", ""), 16) + Offsetter
				let EndAddress = 0n
				let Length = 0n
				if (/^\d+$/.test(LineExtracted[1])) { //If Length is provided
					Length = ParseBigIntValue(LineExtracted[1], 10)
					EndAddress = StartAddress+Length-1n
				} else { //Otherwise if ending address provided
					EndAddress = ParseBigIntValue(LineExtracted[1].replace(/^~/, "").replace(/\$/, ""), 16) + Offsetter
					Length = EndAddress-StartAddress+1n
				}
				if (Length < 1n) {
					ErrorExists = true
					return {
						Type: "Error",
						Reason: "Length less than 1 byte or ending address is less than start address",
						SourceText: SourceText,
						LineNumber: Index
					}
				}
				if (UsedAddress_Min > StartAddress) {
					UsedAddress_Min = StartAddress
				}
				if (UsedAddress_Max < EndAddress) {
					UsedAddress_Max = EndAddress
				}
				return {
					Type: "NonOverlap", //Default type "NonOverlap" that may later discover an overlap.
					LineNumber: Index,
					StartAddress: StartAddress,
					Length: Length,
					EndAddress: EndAddress,
					Description: Description,
					SourceText: SourceText,
					ConflictsWith: [],
					SVGBarXPos: 0n
				}
			})
			if (ErrorExists) {
				document.getElementById("Output_ErrorMessageDiv").hidden = false
				document.getElementById("Output_AddressInfo").hidden = true
				BadObjectOfDataRanges = ObjectOfDataRanges.filter(Item => Item.Type == "Error")
				let ErrorText = "Errors found in the input:\n"
				BadObjectOfDataRanges.forEach((Item, Index, Arr) => {
					ErrorText += "At line " + (Item.LineNumber+1).toString(10) + ": [" + Item.SourceText + "]: "+ Item.Reason
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
					document.getElementById("Output_ErrorMessage").textContent = ErrorText
				})
				
				
				return
			}
			
			//Discover lowest used address and clamp (only happens when editing the textarea) the SVG address view
			document.getElementById("OutputStatistics_UsedAddress_Min").textContent = ""
			if (typeof UsedAddress_Min == "bigint") {
				document.getElementById("OutputStatistics_UsedAddress_Min").textContent = BigIntToStringSignedHex(UsedAddress_Min)
				if (StartingAddressViewing < UsedAddress_Min) {
					StartingAddressViewing = UsedAddress_Min
				}
			}
			document.getElementById("OutputStatistics_UsedAddress_Max").textContent = ""
			if (typeof UsedAddress_Max == "bigint") {
				document.getElementById("OutputStatistics_UsedAddress_Max").textContent = BigIntToStringSignedHex(UsedAddress_Max)
				if (StartingAddressViewing > UsedAddress_Max) {
					StartingAddressViewing = UsedAddress_Max
				}
			}
			
			//Display how many bytes between lowest and highest used address
			document.getElementById("OutputStatistics_TotalBytes_BetweenMinMax").textContent = ""
			if ((typeof UsedAddress_Min == "bigint") && (typeof UsedAddress_Max == "bigint")) {
				document.getElementById("OutputStatistics_TotalBytes_BetweenMinMax").textContent = (UsedAddress_Max - UsedAddress_Min + 1n).toString(10)
			}
			
			
			document.getElementById("SVGAddressView").value = StartingAddressViewing.toString(16).toUpperCase()
			
			ObjectOfDataRanges = ObjectOfDataRanges.filter(Item => Item.Type == "NonOverlap") //This only gets actual ranges (removes errors and "CommentOrBlankLine")
			document.getElementById("Output_ErrorMessageDiv").hidden = true
			document.getElementById("Output_AddressInfo").hidden = false
			//Remove duplicate entries
			if (document.getElementById("Setting_IgnoreDupes").checked)
				ObjectOfDataRanges = ((ItemsList) => {
					let DupeFree = []
					ObjectOfDataRanges.forEach(Item => {
						let DupedItemOriginal = DupeFree.find(Item2 => {
							if ((Item.StartAddress == Item2.StartAddress)&&(Item.Length == Item2.Length)&&(Item.Description == Item2.Description)) {
								return true
							}
						});
						if (typeof DupedItemOriginal == "undefined") {
							DupeFree.push(Item)
						}
					});
					return DupeFree
				})(ObjectOfDataRanges);
			//Find overlaps
			{
				let l = ObjectOfDataRanges.length
				let OverlapCount = 0
				let TotalNonOverlapsBytes = 0n
				for (let i=0; i<l; i++) {
					let Item = ObjectOfDataRanges[i]
					for (let i2 = i+1; i2<l; i2++) {
						let Item2 = ObjectOfDataRanges[i2]
						if (CheckOverlap(Item.StartAddress, Item.EndAddress, Item2.StartAddress, Item2.EndAddress)) {
							Item.Type = "Overlap"
							Item2.Type = "Overlap"
							//NOTE: I rather push only primitive data that is referencing, as opposed to pushing
							//another range object here, as that will cause a circular reference (item A contains
							//ConflictsWith list which reference to item B, which also contains a ConflictsWith
							//listing item A). This causes potential memory leaks.
							//
							//circular reference means things in the memory will never disappear even when identifiers
							//in the code are not referencing it, as garbage collector will assume these are always
							//reference.
							Item.ConflictsWith.push({
								LineNumber: Item2.LineNumber,
								StartAddress: Item2.StartAddress,
								Length: Item2.Length,
								EndAddress: Item2.EndAddress,
								Description: Item2.Description,
								SourceText: Item2.SourceText,
							})
							Item2.ConflictsWith.push({
								LineNumber: Item.LineNumber,
								StartAddress: Item.StartAddress,
								Length: Item.Length,
								EndAddress: Item.EndAddress,
								Description: Item.Description,
								SourceText: Item.SourceText,
							})
						}
					}
					//Count how many items overlaps with another range at least once (so that one item shouldn't count as twice or more)).
					if (Item.ConflictsWith.length != 0) {
						OverlapCount++
					}
					if (Item.Type == "NonOverlap") {
						TotalNonOverlapsBytes += Item.Length
					}
				}
				document.getElementById("OutputStatistics_Overlap").textContent = OverlapCount.toString(10)
				document.getElementById("OutputStatistics_NonOverlap").textContent = (ObjectOfDataRanges.length - OverlapCount).toString(10)
				document.getElementById("OutputStatistics_TotalBytes_NonOverlaps").textContent = TotalNonOverlapsBytes.toString(10)
			}
			GapList = []
			{
				//Get gaps
				//let ArrayCopyButSortedForGapFinding = ListOfAddress.sort(SortByStartAddr) <-This will sort BOTH arrays.
				// Needed in case if we have multiple overlapping address. When having multiple overlapping addresses, the ending address
				// of the last range processed is NOT always the last byte, if we had (1st) one address, and then another (2nd) but shorter range,
				// we wouldn't want to use the ending address of 2nd because we look at the address after the last byte of whoever is the longest.
				// Made up example:
				//  7E0060-7E0063	;>First
				//  7E0061-7E0062	;>Second
				// 7E0063 is what we assume the last byte, not 7E0062. Essentially, HighestEndAddressGapDetect holds the highest ending address
				// currently processed that overlaps.
				let HighestEndAddressGapDetect = -Infinity
				let ObjectOfDataRanges_tempSort = ObjectOfDataRanges.toSorted((a,b) => Number(a.StartAddress-b.StartAddress))
				let l = ObjectOfDataRanges_tempSort.length
				for (let i=1; i<l; i++) {
					//If the highest index exceeds HighestEndAddressGapDetect, replace it with the higher number
					if (ObjectOfDataRanges_tempSort[i-1].EndAddress > HighestEndAddressGapDetect) {
						HighestEndAddressGapDetect = ObjectOfDataRanges_tempSort[i-1].EndAddress
					}
					if (ObjectOfDataRanges_tempSort[i].StartAddress > HighestEndAddressGapDetect+1n) {
						let StartAddress = HighestEndAddressGapDetect+1n
						let Length = ObjectOfDataRanges_tempSort[i].StartAddress - HighestEndAddressGapDetect-1n
						let EndAddress = Length + HighestEndAddressGapDetect
						GapList.push({
							LineNumber: -1,
							StartAddress: StartAddress,
							Length: Length,
							EndAddress: EndAddress,
							Description: "Gap",
							SourceText: BigIntToStringSignedHex(StartAddress) + "\t~" + BigIntToStringSignedHex(EndAddress) + "\tGap",
							Type: "Gap",
							ConflictsWith: [], //This needed to be here else we had to check if this even exists when sorting, making it slow.
							SVGBarXPos: 0n
						})
					}
				}
				document.getElementById("OutputStatistics_Gaps").textContent = GapList.length.toString(10)
				document.getElementById("Button_QuickCopyGaps").disabled = false
				let QuickCopyGapsExistMsg = document.getElementById("QuickCopyGapsExistMsg")
					//^Yes there are 2 spans, one for if the clipboard write succeeds or fails, and the other for if gap exists.
					// But I did this intentionally instead of having just one for both to prevent a bug where if you are fast,
					// you click the quick-copy-gaps button, and then quickly edit the textarea so there are no gaps (to bring
					// up the no-gap message), the settimeout would delete the now-"No gap exists!" message when it should stay
					// there as long as no gaps exists.
				QuickCopyGapsExistMsg.textContent = ""
				if (GapList.length == 0) {
					document.getElementById("Button_QuickCopyGaps").disabled = true
					QuickCopyGapsExistMsg.textContent = "No gap exists!"
					QuickCopyGapsExistMsg.style.color = "#FF0000"
				}
				if (document.getElementById("Filter_Gap").checked) {
					ObjectOfDataRanges = ObjectOfDataRanges.concat(GapList)
				}
				document.getElementById("OutputStatistics_TotalIncludingGaps").textContent = ObjectOfDataRanges.length.toString(10)
			}
			let TotalGapBytes = 0n
			GapList.forEach(Gap => TotalGapBytes += Gap.Length)
			document.getElementById("OutputStatistics_TotalBytes_Gaps").textContent = TotalGapBytes.toString(10)
			
			let TotalNonOverlapsBytes = 0n
			let NonOverlaps = 
			
			SavedAddresses = ObjectOfDataRanges
		} else {
			ObjectOfDataRanges = SavedAddresses
		}
		if (document.getElementById("Setting_ViewMode_Table").checked) {
			document.getElementById("Output_AddressInfo_Text").value = ""
			let OutputTable = document.getElementById("Output_AddressInfo_Table")
			while (OutputTable.lastElementChild) {
				OutputTable.removeChild(OutputTable.lastElementChild)
			}
			let OutputDisplay_ObjectOfDataRanges = ObjectOfDataRanges.filter(Item => document.getElementById("Filter_" + Item.Type).checked)
			document.getElementById("OutputStatistics_TotalAfterFilter").textContent = OutputDisplay_ObjectOfDataRanges.length.toString(10)
			let ReverseSort = document.getElementById("SortOption_Reverse").checked ? -1 : 1
			if (document.getElementById("SortOption_ByAddr").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				OutputDisplay_ObjectOfDataRanges.sort((a,b) => Number((a.StartAddress-b.StartAddress))*ReverseSort)
			} else if (document.getElementById("SortOption_Size").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				OutputDisplay_ObjectOfDataRanges.sort((a,b) => Number((a.Length-b.Length))*ReverseSort)
			} else if (document.getElementById("SortOption_Discription").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				OutputDisplay_ObjectOfDataRanges.sort((a,b) => {
					if (a.Description === b.Description) {
						return 0
					}
					return ((a.Description < b.Description) ? -1 : 1)*ReverseSort
				})
			} else if (document.getElementById("SortOption_Type").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				OutputDisplay_ObjectOfDataRanges.sort((a,b) => {
					if (a.Type === b.Type) {
						return 0
					}
					return ((a.Type < b.Type) ? -1 : 1)*ReverseSort
				})
			} else if (document.getElementById("SortOption_OverlapCount").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				OutputDisplay_ObjectOfDataRanges.sort((a,b) => Number((a.ConflictsWith.Length-b.ConflictsWith.Length))*ReverseSort)
			} else {
				document.getElementById("SortOption_Reverse").disabled = true
			}
			let PlainTextOutput = ""
			
			let Output_TableHeaderRow = document.createElement("tr")
			
			let Output_TableHeader_LineNumber = document.createElement("th")
			Output_TableHeader_LineNumber.appendChild(document.createTextNode("Line number"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_LineNumber)
			
			let Output_TableHeader_StartAddress = document.createElement("th")
			Output_TableHeader_StartAddress.appendChild(document.createTextNode("Starting address"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_StartAddress)
			
			let Output_TableHeader_LengthAndEnd = document.createElement("th")
			Output_TableHeader_LengthAndEnd.appendChild(document.createTextNode("Length/ending address"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_LengthAndEnd)
			
			let Output_TableHeader_Description = document.createElement("th")
			Output_TableHeader_Description.appendChild(document.createTextNode("Description"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_Description)
			
			let Output_TableHeader_Overlap = document.createElement("th")
			Output_TableHeader_Overlap.appendChild(document.createTextNode("Overlap"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_Overlap)
			
			document.getElementById("Output_AddressInfo_Table").appendChild(Output_TableHeaderRow)
			
			OutputDisplay_ObjectOfDataRanges.forEach((Item, index, Arr) => {
				PlainTextOutput += BigIntToStringSignedHex(Item.StartAddress) + "\t"
				if (document.getElementById("PlaintextSetting_Output_Size").selected) {
					PlainTextOutput += Item.Length.toString(10)
				} else if (document.getElementById("PlaintextSetting_Output_Ending").selected) {
					PlainTextOutput += "~" + BigIntToStringSignedHex(Item.EndAddress)
				} else if (document.getElementById("PlaintextSetting_Output_SizeAndEnding").selected) {
					PlainTextOutput += Item.Length.toString(10) + "/~" + BigIntToStringSignedHex(Item.EndAddress)
				}
				PlainTextOutput += "\t" + Item.Description
				
				let TableItemRow = document.createElement("tr")
				
				let TableItem_LineNumber = document.createElement("td")
				TableItem_LineNumber.style.fontFamily = "monospace"
				TableItem_LineNumber.style.backgroundColor = ColorCodedStatus[Item.Type]
				if (Item.LineNumber != -1) {
					TableItem_LineNumber.appendChild(document.createTextNode((Item.LineNumber+1).toString(10)))
				}
				TableItemRow.appendChild(TableItem_LineNumber)
				
				let TableItem_StartAddress = document.createElement("td")
				TableItem_StartAddress.style.fontFamily = "monospace"
				TableItem_StartAddress.style.backgroundColor = ColorCodedStatus[Item.Type]
				TableItem_StartAddress.appendChild(document.createTextNode(BigIntToStringSignedHex(Item.StartAddress)))
				TableItemRow.appendChild(TableItem_StartAddress)
				
				let TableItem_LengthEnd = document.createElement("td")
				TableItem_LengthEnd.style.fontFamily = "monospace"
				TableItem_LengthEnd.style.backgroundColor = ColorCodedStatus[Item.Type]
				TableItem_LengthEnd.appendChild(document.createTextNode(Item.Length.toString(10) + "/" + BigIntToStringSignedHex(Item.EndAddress)))
				TableItemRow.appendChild(TableItem_LengthEnd)
				
				let TableItem_Description = document.createElement("td")
				TableItem_Description.style.fontFamily = "monospace"
				TableItem_Description.style.backgroundColor = ColorCodedStatus[Item.Type]
				TableItem_Description.appendChild(document.createTextNode(Item.Description))
				TableItemRow.appendChild(TableItem_Description)
				
				let TableItem_Overlap = document.createElement("td")
				TableItem_Overlap.style.backgroundColor = ColorCodedStatus[Item.Type]
				
				TableItemRow.appendChild(TableItem_Overlap)
				
				if (document.getElementById("PlaintextSetting_Output_OverlapStatus").checked) {
					if (Item.ConflictsWith.length != 0) {
						PlainTextOutput += "\n\t;^Overlaps with:\n"
						
						let OverlappedItem_Table = document.createElement("table")
						let OverlappedItem_HeaderRow = document.createElement("tr")
						
						let OverlappedItem_HeaderLineNumb = document.createElement("th")
						OverlappedItem_HeaderLineNumb.appendChild(document.createTextNode("Line number"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_HeaderLineNumb)
						
						let OverlappedItem_HeaderStart = document.createElement("th")
						OverlappedItem_HeaderStart.appendChild(document.createTextNode("Starting address"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_HeaderStart)
						
						let OverlappedItem_LengthEnd = document.createElement("th")
						OverlappedItem_LengthEnd.appendChild(document.createTextNode("length/end"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_LengthEnd)
						
						let OverlappedItem_Description = document.createElement("th")
						OverlappedItem_Description.appendChild(document.createTextNode("Description"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_Description)
						
						OverlappedItem_Table.appendChild(OverlappedItem_HeaderRow)
						
						Item.ConflictsWith.forEach((overlapped, index2, Arr2) => {
							PlainTextOutput += "\t;Line " + (Item.LineNumber+1).toString(10) + ": " + BigIntToStringSignedHex(overlapped.StartAddress) + "\t"
							if (document.getElementById("PlaintextSetting_Output_Size").selected) {
								PlainTextOutput += overlapped.Length.toString(10)
							} else if (document.getElementById("PlaintextSetting_Output_Ending").selected) {
								PlainTextOutput += "~" + BigIntToStringSignedHex(overlapped.EndAddress)
							} else if (document.getElementById("PlaintextSetting_Output_SizeAndEnding").selected) {
								PlainTextOutput += overlapped.Length.toString(10) + "/~" + BigIntToStringSignedHex(overlapped.EndAddress)
							}
							PlainTextOutput += "\t" + overlapped.Description
							if (index2 != Arr2.length-1) {
								PlainTextOutput += "\n"
							}
							
							let OverlappedItem_RowConflict = document.createElement("tr")
							
							let OverlappedItem_LineNumber = document.createElement("td")
							OverlappedItem_LineNumber.style.fontFamily = "monospace"
							OverlappedItem_LineNumber.appendChild(document.createTextNode((overlapped.LineNumber+1).toString(10)))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_LineNumber)
							
							let OverlappedItem_Start = document.createElement("td")
							OverlappedItem_Start.style.fontFamily = "monospace"
							OverlappedItem_Start.appendChild(document.createTextNode(BigIntToStringSignedHex(overlapped.StartAddress)))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_Start)
							
							let OverlappedItem_LengthEnd = document.createElement("td")
							OverlappedItem_LengthEnd.style.fontFamily = "monospace"
							OverlappedItem_LengthEnd.appendChild(document.createTextNode(overlapped.Length.toString(10) + "/" + BigIntToStringSignedHex(overlapped.EndAddress)))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_LengthEnd)
							
							let OverlappedItem_Description = document.createElement("td")
							OverlappedItem_Description.style.fontFamily = "monospace"
							OverlappedItem_Description.appendChild(document.createTextNode(overlapped.Description))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_Description)
							
							OverlappedItem_Table.appendChild(OverlappedItem_RowConflict)
						})
						TableItem_Overlap.appendChild(OverlappedItem_Table)
					}
				}
				
				if (index != Arr.length-1) {
					PlainTextOutput += "\n"
				}
				document.getElementById("Output_AddressInfo_Table").appendChild(TableItemRow)
			})
			document.getElementById("Output_AddressInfo_Text").value = PlainTextOutput
		} else {
			//Clear the graph
			SVG_GraphElement.style.width = (Setting_ByteView_NumberOfColumns*Setting_ByteView_SVGGridSizeFactor)
			SVG_GraphElement.style.height = (Setting_ByteView_NumberOfRows*Setting_ByteView_SVGGridSizeFactor).toString(10) + "px"
			while (SVG_GraphElement.lastElementChild) {
				SVG_GraphElement.removeChild(SVG_GraphElement.lastElementChild)
			}
			
			if (NeedsToUpdateSVGOrder) {
				//Sort so when overlaps occurs, what appears first in the overlap group appears on the leftmost.
				SavedSortedForSVGOrder = SavedAddresses.toSorted((a,b) => Number((a.StartAddress-b.StartAddress)))
				
				NeedsToUpdateSVGOrder = false
				if (SavedSortedForSVGOrder.length > 1) {
					//Adjust X position so overlapped bars are placed to the right until they don't
					let l = SavedSortedForSVGOrder.length
					for (let i=0; i<l; i++) {
						let isOverlappingXY = false
						do {
							isOverlappingXY = false
							for (let i2=0; i2<i && (!isOverlappingXY); i2++) { //Loop all previous before current index
								let isAddrOverlapping = CheckOverlap(SavedSortedForSVGOrder[i].StartAddress, SavedSortedForSVGOrder[i].EndAddress, SavedSortedForSVGOrder[i2].StartAddress, SavedSortedForSVGOrder[i2].EndAddress)
								let isSVGBarXPosOverlapping = SavedSortedForSVGOrder[i].SVGBarXPos == SavedSortedForSVGOrder[i2].SVGBarXPos
								if (isAddrOverlapping && isSVGBarXPosOverlapping) {
									isOverlappingXY = true
								}
							}
							if (isOverlappingXY) {
								SavedSortedForSVGOrder[i].SVGBarXPos++
							}
						} while (isOverlappingXY) //If still overlapping, repeat
					}
				}
			}
			
			//Line seperator
			for (let i=0n; i<Setting_ByteView_NumberOfRows; i++) {
				let AddressSeperatorLine = createSVGElement("line")
				AddressSeperatorLine.setAttribute("stroke", "#ffffff")
				AddressSeperatorLine.setAttribute("x1", "0")
				AddressSeperatorLine.setAttribute("x2", (Setting_ByteView_NumberOfColumns*Setting_ByteView_SVGGridSizeFactor).toString(10))
				AddressSeperatorLine.setAttribute("y1", (i*Setting_ByteView_SVGGridSizeFactor).toString(10))
				AddressSeperatorLine.setAttribute("y2", (i*Setting_ByteView_SVGGridSizeFactor).toString(10))
				SVG_GraphElement.appendChild(AddressSeperatorLine)
			}
			
			
			//Generate bars representing an address range
			SavedSortedForSVGOrder.forEach(Item => {
				let AddressRect = createSVGElement("rect")
				AddressRect.setAttribute("rx", "8")
				AddressRect.setAttribute("ry", "8")
				AddressRect.setAttribute("fill", ColorCodedStatus[Item.Type])
				
				//These need to be clamped so that the height wouldn't be such a large value that the SVG render would fail drawing them. It's clamped to a distance off-canvas so that the rounded corners indicating the start/end
				//wouldn't display at the visible edge lying to the user that the start/end address would be there.
				let TopPos = BigintClamp((Item.StartAddress-StartingAddressViewing)*Setting_ByteView_SVGGridSizeFactor, -Setting_ByteView_SVGGridSizeFactor, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
				let BottomPos = BigintClamp((Item.EndAddress-StartingAddressViewing+1n)*Setting_ByteView_SVGGridSizeFactor, -Setting_ByteView_SVGGridSizeFactor, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
				let Height = BottomPos-TopPos
				
				AddressRect.setAttribute("height", Height.toString(10))
				AddressRect.setAttribute("width", Setting_ByteView_SVGGridSizeFactor.toString(10))
				
				AddressRect.setAttribute("x", (BigintClamp(70n + (Item.SVGBarXPos-SVGHorizontalScroll)*Setting_ByteView_SVGGridSizeFactor, -Setting_ByteView_SVGGridSizeFactor/2n, (Setting_ByteView_NumberOfColumns*Setting_ByteView_SVGGridSizeFactor)-Setting_ByteView_SVGGridSizeFactor/2n)).toString(10))
				AddressRect.setAttribute("y", TopPos.toString(10))
				
				let TitleHover = createSVGElement("title")
				TitleHover.appendChild(document.createTextNode(BigIntToStringSignedHex(Item.StartAddress) + "\t" + Item.Length.toString(10) + "/~" + BigIntToStringSignedHex(Item.EndAddress) + "\t" + Item.Description))
				AddressRect.appendChild(TitleHover)
				
				SVG_GraphElement.appendChild(AddressRect)
			})
			
			
			//Generate addresses text (not merged with the line separator loop so that numbers are written on top of the bars when horizontal scroll is applied)
			for (let i=0n; i<Setting_ByteView_NumberOfRows; i++) {
				let AddressText = createSVGElement("text")
				AddressText.setAttribute("fill", "#ffffff")
				AddressText.setAttribute("font-weight", "lighter")
				AddressText.setAttribute("text-anchor", "left")
				AddressText.setAttribute("dominant-baseline", "hanging")
				AddressText.setAttribute("font-family", "monospace")
				AddressText.appendChild(document.createTextNode(BigIntToStringSignedHex((StartingAddressViewing+i))))
				AddressText.setAttribute("transform", "translate(0, " + (i*Setting_ByteView_SVGGridSizeFactor).toString(10) + ")")
				SVG_GraphElement.appendChild(AddressText)
			}
			
		}
	}
	function CopyGaps() {
		let CopiedString = ""
		GapList.forEach((Item, Index, Arr) => {
			CopiedString += BigIntToStringSignedHex(Item.StartAddress) + "\t" + Item.Length.toString(10) + "\tGap"
			if (Index != Arr.length-1) {
				CopiedString += "\n"
			}
			setClipboard(CopiedString)
		})
	}
//helper
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function ModifyCheckboxes(node, checkState) {
		[...node.querySelectorAll("input[type=checkbox]")].forEach(ele => {
			if (checkState == 0 || checkState == 1) {
				ele.checked = checkState
			} else {
				ele.checked = !ele.checked
			}
		});
	}
	
	function keyHandler_Tab(e) {

		let target;
		if (!e) e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				let startPos = target.selectionStart;
				let endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			return (B_End >= A_Start&&B_Start <= A_End)
		}
	function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
		return document.createElementNS('http://www.w3.org/2000/svg', tag)
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
			return num <= min ? min : num >= max ? max : num;
	}
	function BigIntToStringSignedHex(BigIntVal) {
		//Converts a bigint value into a signed ASM-styled hex number:
		//16n -> "$10"
		//-16n -> "-$10"
		let StringOutput = ""
		if (BigIntVal >= 0n) {
			StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
		} else {
			StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
		}
		return StringOutput
	}
	function DeleteCopyMessage(HTMLElement) {
		HTMLElement.textContent = ""
	}
	
	function setClipboard(String) {
		//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
		const type = "text/plain";
		const blob = new Blob([String], { type });
		const data = [new ClipboardItem({ [type]: blob })];
		
		let EventElement = event.target
		let CopiedMessage = EventElement.parentNode.querySelector("span")
	
		navigator.clipboard.write(data).then(
			((EventElement) => {
			/* success */
				CopiedMessage.textContent = "Copied!"
				CopiedMessage.style.color = "#00FF00"
				setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
			}).bind(null, EventElement),
			((EventElement) => {
			/* failure */
				CopiedMessage.textContent = "Failed!"
				CopiedMessage.style.color = "#FF0000"
				setTimeout(DeleteCopyMessage.bind(null, CopiedMessage), 1500)
			}).bind(null, EventElement)
		);
	}
	AutoEnterSMWInput()
	
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
	function AutoEnterSMWInput() {
		const SMWUsedRAMText = `$7E0000	~$7E0057	RAM used by SMW.
$7E0059	~$7E005B	RAM used by SMW.
$7E005D	~$7E005F	RAM used by SMW.
$7E0064	~$7E0078	RAM used by SMW.
$7E007A	~$7E007B	RAM used by SMW.
$7E007D	~$7E0086	RAM used by SMW.
$7E0088	~$7E00EF	RAM used by SMW.
$7E00F0	~$7E00FF	RAM used by LM.
$7E0100	~$7E049F	RAM used by SMW.
$7E04A0	~$7E065C	RAM used by SMW. Remove if "Free $7E04A0" patch installed
$7E065D	~$7E0694	RAM used by SMW.
$7E0695	100	Used by LM 1.70+ for VRAM modification.
$7E0701	~$7E0AF4	RAM used by SMW.
$7E0AF6	~$7E0D9B	RAM used by SMW.
$7E0D9D	~$7E0DA0	RAM used by SMW.
$7E0DA2	~$7E0DC2	RAM used by SMW.
$7E0DC7	~$7E0DD8	RAM used by SMW.
$7E0DDA	1	RAM used by SMW.
$7E0DDE	~$7E0F39	RAM used by SMW.
$7E0F40	~$7E0F41	RAM used by SMW.
$7E0F48	~$7E0F5D	RAM used by SMW.
$7E0F72	~$7E13C7	RAM used by SMW.
$7E13C9	~$7E13E5	RAM used by SMW.
$7E13E8	~$7E13F1	RAM used by SMW.
$7E13F3	~$7E1409	RAM used by SMW.
$7E140D	~$7E1414	RAM used by SMW.
$7E1417	~$7E142B	RAM used by SMW.
$7E142C	~$7E142F	RAM used by SMW. Note: if using Center Scroll with !Setting_CenterScroll_ScrollType set to 0, remove this.
$7E1430	~$7E1460	RAM used by SMW.
$7E1462	~$7E146B	RAM used by SMW.
$7E1470	~$7E1472	RAM used by SMW.
$7E1474	1	RAM used by SMW.
$7E1476	1	RAM used by SMW.
$7E1478	1	RAM used by SMW.
$7E147A	1	RAM used by SMW.
$7E147C	1	RAM used by SMW.
$7E147E	~$7E1486	RAM used by SMW.
$7E148B	~$7E14AB	RAM used by SMW.
$7E14AD	~$7E14BD	RAM used by SMW.
$7E14BF	~$7E14C0	RAM used by SMW.
$7E14C2	~$7E14C3	RAM used by SMW.
$7E14C5	~$7E14C6	RAM used by SMW.
$7E14C8	~$7E15E7	RAM used by SMW.
$7E15E9	~$7E1695	RAM used by SMW.
$7E1697	~$7E17BA	RAM used by SMW.
$7E17BC	~$7E1863	RAM used by SMW.
$7E1865	~$7E1868	RAM used by SMW.
$7E186B	~$7E1878	RAM used by SMW.
$7E187A	~$7E1889	RAM used by SMW.
$7E188B	~$7E188D	RAM used by SMW.
$7E188F	~$7E18A5	RAM used by SMW.
$7E18A7	~$7E18B3	RAM used by SMW.
$7E18B5	~$7E18B6	RAM used by SMW.
$7E18B8	~$7E18BA	RAM used by SMW.
$7E18BC	~$7E18C4	RAM used by SMW.
$7E18CD	~$7E18D7	RAM used by SMW.
$7E18D9	~$7E18DA	RAM used by SMW.
$7E18DC	~$7E18E5	RAM used by SMW.
$7E18E7	~$7E18F5	RAM used by SMW.
$7E18F7	~$7E1907	RAM used by SMW.
$7E1909	~$7E191A	RAM used by SMW.
$7E191C	~$7E191E	RAM used by SMW.
$7E1920	~$7E1922	RAM used by SMW.
$7E1925	1	RAM used by SMW.
$7E1928	1	RAM used by SMW.
$7E192A	~$7E192B	RAM used by SMW.
$7E192D	~$7E1B7E	RAM used by SMW.
$7E1B80	~$7E1B96	RAM used by SMW.
$7E1B99	~$7E1DEE	RAM used by SMW.
$7E1DF0	~$7E1DFC	RAM used by SMW.
$7E1DFF	1	RAM used by SMW.
$7E1E02	~$7E1F2A	RAM used by SMW.
$7E1F2E	~$7E1F3A	RAM used by SMW.
$7E1F3C	~$7E1F47	RAM used by SMW.
$7E1F49	~$7E1FF9	RAM used by SMW.
$7E1FFB	~$7E1FFE	RAM used by SMW.
$7E2000	~$7EACFF	RAM used by SMW. Note: Remove this if Free up RAM $7E2000 is installed.
$7EAD00	~$7EB8FF	RAM used by SMW and LM's examination
$7EB900	~$7EBCFF	RAM used by SMW.
$7EBD00	~$7EC0FF	RAM used by SMW.
$7EC100	~$7EC67F	Originally empty, but LM use this for examination.
$7EC680	~$7EC6DF	RAM used by SMW.
$7EC6E0	~$7EC7FF	Empty, untouched RAM on an unhacked ROM. In a hacked ROM, it may be occupied by ExAnimation data (see $7E:C100).
$7EC800	~$7EFFFF	RAM used by SMW.
$7F0000	~$7F3FFF	RAM used by SMW. Note: Remove this if Free $7F0000 (OW Event Restore) is installed.
$7F4000	~$7F7FFF	RAM used by SMW.
$7F8000	~$7F8182	RAM used by SMW. Note: Remove this if Free up RAM $7F:8000 is installed
$7F8183	~$7F837A	Empty, but partially taken by LM. Not sure the exact amount of bytes used though.
$7F837B	~$7F9C7A	RAM used by SMW.
$7F9C7B	~$7FC7FF	Empty, but partially used by other SMW tools.
$7FC800	~$7FFFFF	RAM used by SMW.`
		document.getElementById("UserInputList").value = SMWUsedRAMText
		document.getElementById("UserInputList").oninput()
	}
	function ClearInputList() {
		document.getElementById("UserInputList").value = ""
		document.getElementById("UserInputList").oninput()
	}
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
</script>