<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			svg {
				fill: white;
				font-family: monospace;
			}
			rect:hover {
				fill: blue
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			select, option {
				font-family: monospace;
			}
			
			textarea {
				white-space: pre;
				overflow-wrap: normal;
				overflow-x: scroll;
			}
		</style>
	</head>
<body>

<p>Entere a list of RAM or any memory usage in the textarea below. Must be formatted like this:
<table><tr><td><pre>Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description
Address	Size_in_bytes_Or_EndAddress	Description</pre></td></tr></table><br>
Make sure the format is:
<ul>
	<li>No additional tabs, meaning multiple tabs that are used to align columns in text editors is not allowed. The tab character is reserved for <a href="https://en.wikipedia.org/wiki/Tab-separated_values">tab-separated values</a>.</li>
</ul>
</p>

Notes:
	<ul>
		<li>Lines that are blank or composed of just any whitespace characters are ignored. It will also ignore any lines that start with either a semicolon or a space (0 or more), followed by a semicolon (therefore ASM-styled comments are allowed).</li>
		<li>Whitespace shown above is a TAB character, not a literal space character.</li>
		<li>This does not take in account of addressing mirroring (a shorthand <kbd>$00</kbd> instead of <kbd>$7E0000</kbd>), so I strongly recommend putting the full address numbers here. Furthermore, it does not detect what type of memory map it is,
		things like negative address (only shown on &ldquo;<kbd>Potential ending address before the starting byte of all the ranges</kbd>&rdquo;), address pointing beyond the last byte of the entire memory map, and so on.</li>
		<li>This tool could be applied to other systems (beyond the SNES), since it merely check ranges.</li>
	</ul>

Where:
<ul>
	<li><kbd>Address</kbd> is the starting address, in hex. <kbd>$</kbd> prefix is optional.</li>
	<li><kbd>Size_in_bytes_Or_EndAddress</kbd> can either be the number of bytes starting from <kbd>Address</kbd> and ending at <kbd>Address + Size_in_bytes - 1</kbd> or the ending address:
		<ul>
			<li><kbd>Decimal_Number</kbd> - number of bytes, in decimal. Don't use commas to separate digit grouping.</li>
			<li><kbd>~Hexidecimal_EndAddress</kbd> - the ending address (note the tilde to denote a range), in hex. Also <kbd>$</kbd> prefix is optional (must be placed after
			the tilde and before the hexadecimal address number (example: <kbd>$~10</kbd> is wrong, <kbd>~$10</kbd> is correct)).</li>
		</ul>
	</li>
	<li><kbd>Description</kbd> (optional) is a brief description. Note: HTML tags, elements and other reserved symbols apply on the description, and improper opening and closing/ending tags could <abbr title="For example: having only the opening tag or closing/ending tag, if you end the table tag (/td/tr/table), before you start it (tabletrtd), it would mess up the outer table's content after the invalid HTML setup.">break the table</abbr>!
	If you want to view the table with invalid tag setup and have it not be broken, check the box labeled &ldquo;Escape html tags and escape characters for table description&rdquo;, and it will cancel out the HTML effects (they're <a href="https://en.wikipedia.org/wiki/Character_encodings_in_HTML#XML_character_references">escaped</a>) within the description field.</li>
</ul>

<textarea id="UserInputList" cols="75" rows="30" oninput="HaveEditedTextarea = true; NeedsToUpdateSVGOrder = true; MainCode()" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>
<div>
	View mode:
	<div><label><input type="radio" name="Setting_ViewMode" onchange="AdjustMode()" id="Setting_ViewMode_Table" checked>Table range</label></div>
	<div><label><input type="radio" name="Setting_ViewMode" onchange="AdjustMode()" id="Setting_ViewMode_Byte">Byte view</label></div>
</div>
<hr>
<label><input type="checkbox" id="Setting_IgnoreDupes" onchange="HaveEditedTextarea = true; MainCode()" checked>Ignore duplicates</label>
<div id="SettingPanel_TableViewOptions">
	Sort: <select onchange="SortChanges = true; MainCode()">
		<option id="SortOption_None">Keep order you entered</option>
		<option id="SortOption_ByAddr" selected>By start address</option>
		<option id="SortOption_Size">By size</option>
		<option id="SortOption_Discription">By description (lexicographically)</option>
		<option id="SortOption_Type">By type</option>
		<option id="SortOption_OverlapCount">By overlap count</option>
	</select><label><input type="checkbox" id="SortOption_Reverse" onchange="SortChanges = true; MainCode()">Reverse order</label><br><br>
	<div>Filter by: <button onclick="ModifyCheckboxes(this.parentNode, 1); SortChanges=true; MainCode();">Check all</button><button onclick="ModifyCheckboxes(this.parentNode, 0); MainCode();">Uncheck all</button><button onclick="ModifyCheckboxes(this.parentNode, 2); MainCode();">Invert</button>
		<div><label><input type="checkbox" onchange="SortChanges = true; MainCode()" checked id="Filter_Gap">Unused gaps</label></div>
		<div><label><input type="checkbox" onchange="SortChanges = true; MainCode()" checked id="Filter_NonOverlap">Address with no conflicts</label></div>
		<div><label><input type="checkbox" onchange="SortChanges = true; MainCode()" checked id="Filter_Overlap">Address that conflicted</label></div>
	</div><br><br>
	Plaintext size/ending address mode display: <select onchange="MainCode();">
		<option id="PlaintextSetting_Output_Size">Size</option>
		<option id="PlaintextSetting_Output_Ending">Ending</option>
		<option id="PlaintextSetting_Output_SizeAndEnding">Size and ending (&lt;size&gt;/-&lt;ending_address&gt;)</option>
	</select><label><input type="checkbox" id="PlaintextSetting_Output_OverlapStatus" checked onchange="MainCode()">Show gap/overlap/non-overlap status</label>
</div>
<div id="SettingPanel_ByteViewOptions" hidden>
	Address to view: $<input type="text" value="7E0000" class="HexNumberInput" id="SVGAddressView"><br>
	Useful tips using this feature:
	<ul>
	<li>Hover your mouse over the display and roll your scroll wheel to scroll the graph</li>
	<li>To scroll by an entire screen, hold SHIFT and roll your scroll wheel. You can also do this by clicking on the graph and press page up/down.</li>
	</ul>
</div>
<hr>
<pre hidden id="Output_ErrorMessage" style="border: 1px solid white"></pre>
<div id="Output_AddressInfo">
	<div id="ViewMode_TextTable">
		<textarea id="Output_AddressInfo_Text" readonly cols="75" rows="30" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color: #000000; color: white"></textarea>
		<div style="overflow: auto; height: 500px">
			<table id="Output_AddressInfo_Table"></table>
		</div>
	</div>
	<div id="ViewMode_AddressBytes" hidden>
		<svg id="SVGGraph" style="width: 400px; height: 700px; border: 1px solid white" tabindex="0"></svg>
	</div>
</div>
<script>
	const Setting_ByteView_SVGGridSizeFactor = 16n
	const Setting_ByteView_AddressColumnPosition = 5n		//Note: right-aligned, from text-anchor, position of the right edge of text
	const Setting_ByteView_BarsXPosStart = 5n			//Note: left-aligned, position from left edge.
	const Setting_ByteView_NumberOfRows = 100n
	const Setting_ByteView_NumberOfColumns = 20n			//Width of viewbox, that, multiplied by Setting_ByteView_SVGGridSizeFactor
	
	let SavedAddresses = []
	let HaveEditedTextarea = false
	let SortChanges = true
	let NeedsToUpdateSVGOrder = false
	let SavedSortedForSVGOrder = []
	
	let ColorCodedStatus = {
	"Gap": "#808080",
	"NonOverlap" : "#008000",
	"Overlap" : "#800000"
	}
	let SVG_GraphElement = document.getElementById("SVGGraph")
	AddHexIncrementDecrementToTextInputs()
	document.getElementById("UserInputList").addEventListener("keydown", this.keyHandler_Tab, false)
	SVG_GraphElement.addEventListener(
		"wheel",
		function (e) {
			e.preventDefault()
			let AddressView = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
			let ScrollSize = 4n
			if (e.shiftKey) {
				ScrollSize = Setting_ByteView_NumberOfRows
			}
			if (e.deltaY > 0) {
				AddressView = AddressView+ScrollSize
			} else if (e.deltaY < 0) {
				AddressView = AddressView-ScrollSize
			}
			document.getElementById("SVGAddressView").value = AddressView.toString(16).toUpperCase()
			MainCode()
		}
	
	)
	SVG_GraphElement.addEventListener(
		"keydown",
		function (e) {
			let shouldUpdateOutput = false
			
			let InputKeyPressed = e.key
			if (InputKeyPressed == "ArrowUp"||InputKeyPressed == "ArrowDown"||InputKeyPressed == "PageUp"||InputKeyPressed == "PageDown") {
				e.preventDefault()
				shouldUpdateOutput = true
			}
			let AddressView = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
			if (InputKeyPressed == "ArrowUp") {
				AddressView = AddressView-4n
			} else if (InputKeyPressed == "ArrowDown") {
				AddressView = AddressView+4n
			} else if (InputKeyPressed == "PageUp") {
				AddressView = AddressView-Setting_ByteView_NumberOfRows
			} else if (InputKeyPressed == "PageDown") {
				AddressView = AddressView+Setting_ByteView_NumberOfRows
			}
			document.getElementById("SVGAddressView").value = AddressView.toString(16).toUpperCase()
			if (shouldUpdateOutput) {
				//This if statement above prevents a bug where your text selection gets canceled on keypress
				//because MainCode() will clear the output elements before writing a new output, thus
				//deleting content you've selected.
				MainCode()
			}
		}
	)
	
	function AddHexIncrementDecrementToTextInputs() {
		//Elements you want to apply to must contain a class "HexNumberInput"
		[...document.querySelectorAll("input.HexNumberInput")].forEach(TextInput => {
			TextInput.addEventListener(
				"keydown",
				((e) => {
					let KeyName = e.key
					if (/(?:ArrowUp|ArrowDown)/.test(KeyName)) {
						let Str = e.target.value
						try {
							let IntegerValue = ParseBigIntValue(Str, 16)
							if (KeyName == "ArrowUp") {
								e.preventDefault()
								IntegerValue++
							} else if (KeyName == "ArrowDown") {
								e.preventDefault()
								IntegerValue--
							}
							e.target.value = IntegerValue.toString(16).toUpperCase()
							MainCode()
						} catch {}
					}
				}).bind(TextInput)
			);
			TextInput.addEventListener(
				"change",
				((e) => {
					let Str = e.target.value
					let IntegerValue = ParseBigIntValue(Str, 16)
					e.target.value = IntegerValue.toString(16).toUpperCase()
					MainCode()
				})
			)
		});
	}
	function AdjustMode() {
		if (document.getElementById("Setting_ViewMode_Table").checked) {
			document.getElementById("SettingPanel_TableViewOptions").hidden = false
			document.getElementById("SettingPanel_ByteViewOptions").hidden = true
			document.getElementById("ViewMode_TextTable").hidden = false
			document.getElementById("ViewMode_AddressBytes").hidden = true
		} else if (document.getElementById("Setting_ViewMode_Byte").checked) {
			document.getElementById("SettingPanel_TableViewOptions").hidden = true
			document.getElementById("SettingPanel_ByteViewOptions").hidden = false
			document.getElementById("ViewMode_TextTable").hidden = true
			document.getElementById("ViewMode_AddressBytes").hidden = false
		}
		MainCode()
	}
	function MainCode() {
		ObjectOfDataRanges = []
		if (HaveEditedTextarea) {
			HaveEditedTextarea = false
			let LinesOfText = document.getElementById("UserInputList").value.split('\n')
			LinesOfText = LinesOfText.map((Line, Index) => {
				return {LineNumber: Index, LineText: Line}
			})
			LinesOfText = LinesOfText.filter(Line => {
				if (/(?:^\s*;|^\s*$)/.test(Line.LineText)) { //Lines that begin with any number of spaces and then a semicolon
					return false
				}
				return true
			});
			let BadLines = LinesOfText.filter(Line => {
				if (/^-?\$?[\da-fA-F]+\t(?:\d+|\~-?\$?[\da-fA-F]+)(?:\t.*)?$/.test(Line.LineText)) {
					return false
				}
				return true
			});
			if (BadLines.length != 0) {
				document.getElementById("Output_ErrorMessage").hidden = false
				document.getElementById("Output_AddressInfo").hidden = true
				let ErrorText = ""
				ErrorText += "Error! These lines contain invalid info:\n"
				BadLines.forEach((Line, Index, Arr) => {
					ErrorText += "Line " + (Line.LineNumber+1).toString(10) + ": " + Line.LineText
					if (Index != Arr.length-1) {
						ErrorText += "\n"
					}
				})
				document.getElementById("Output_ErrorMessage").textContent = ErrorText
				return
			}
			ObjectOfDataRanges = LinesOfText.map(Line => {
				let LineExtracted = Line.LineText.split('\t')
				let StartAddress = ParseBigIntValue(LineExtracted[0].replace("$", ""), 16)
				let EndAddress = 0n
				let Length = 0n
				let SourceText = Line.LineText
				
				if (/^\d+$/.test(LineExtracted[1])) { //If Length is provided
					Length = ParseBigIntValue(LineExtracted[1], 10)
					EndAddress = StartAddress+Length-1n
				} else { //Otherwise if ending address provided
					EndAddress = ParseBigIntValue(LineExtracted[1].replace(/^~/, "").replace(/^\$/, ""), 16)
					Length = EndAddress-StartAddress+1n
				}
				let Description = LineExtracted[2] ?? ""
				return {
					LineNumber: Line.LineNumber,
					StartAddress: StartAddress,
					Length: Length,
					EndAddress: EndAddress,
					Description: Description,
					SourceText: SourceText,
					Type: "NonOverlap",
					ConflictsWith: [],
					SVGBarXPos: 0n
				}
			})
			let BadObjectOfDataRanges = ObjectOfDataRanges.filter(ByteRange => {
				if (ByteRange.Length >= 1) {
					return false
				}
				return true
			})
			if (BadObjectOfDataRanges.length != 0) {
				document.getElementById("Output_ErrorMessage").hidden = false
				document.getElementById("Output_AddressInfo").hidden = true
				let ErrorText = ""
				ErrorText += "Error! These ranges either have a size of less than 1 byte or an ending address before the start:\n"
				BadObjectOfDataRanges.forEach((Item, Index, Arr) => {
					ErrorText += "Line " + (Item.LineNumber+1)+1 + ": " + Item.SourceText
					if (Index != Arr.length) {
						ErrorText += "\n"
					}
				})
				document.getElementById("Output_ErrorMessage").textContent = ErrorText
				return
			}
			document.getElementById("Output_ErrorMessage").hidden = true
			document.getElementById("Output_AddressInfo").hidden = false
			//Remove duplicate entries
			ObjectOfDataRanges = ((ItemsList) => {
				let DupeFree = []
				ObjectOfDataRanges.forEach(item => {
					let DupedItemOriginal = DupeFree.find(item2 => {
						if ((item.StartAddress == item2.StartAddress)&&(item.Length == item2.Length)&&(item.Description == item2.Description)) {
							return true
						}
					})
					if (typeof DupedItemOriginal == "undefined") {
						DupeFree.push(item)
					}
				})
				return DupeFree
			})(ObjectOfDataRanges);
			//Find overlaps
			{
				let l = ObjectOfDataRanges.length
				for (let i=0; i<l; i++) {
					let item = ObjectOfDataRanges[i]
					for (let i2 = i+1; i2<l; i2++) {
						let item2 = ObjectOfDataRanges[i2]
						if (CheckOverlap(item.StartAddress, item.EndAddress, item2.StartAddress, item2.EndAddress)) {
							item.Type = "Overlap"
							item2.Type = "Overlap"
							item.ConflictsWith.push({
								StartAddress: item2.StartAddress,
								Length: item2.Length,
								EndAddress: item2.EndAddress,
								Description: item2.Description,
								SourceText: item2.SourceText,
							})
							item2.ConflictsWith.push({
								StartAddress: item.StartAddress,
								Length: item.Length,
								EndAddress: item.EndAddress,
								Description: item.Description,
								SourceText: item.SourceText,
							})
						}
					}
				}
			}
			{
				//Get gaps
				//let ArrayCopyButSortedForGapFinding = ListOfAddress.sort(SortByStartAddr) <-This will sort BOTH arrays.
				// Needed in case if we have multiple overlapping address. When having multiple overlapping addresses, the ending address
				// of the last range processed is NOT always the last byte, if we had (1st) one address, and then another (2nd) but shorter range,
				// we wouldn't want to use the ending address of 2nd because we look at the address after the last byte of whoever is the longest.
				// Made up example:
				//  7E0060-7E0063	;>First
				//  7E0061-7E0062	;>Second
				// 7E0063 is what we assume the last byte, not 7E0062. Essentially, HighestEndAddressGapDetect holds the highest ending address
				// currently processed that overlaps.
				let HighestEndAddressGapDetect = -Infinity
				let GapList = []
				let ObjectOfDataRanges_tempSort = ObjectOfDataRanges.sort((a,b) => Number(a.StartAddress-b.StartAddress))
				let l = ObjectOfDataRanges_tempSort.length
				for (let i=1; i<l; i++) {
					//If the highest index exceeds HighestEndAddressGapDetect, replace it with the higher number
					if (ObjectOfDataRanges_tempSort[i-1].EndAddress > HighestEndAddressGapDetect) {
						HighestEndAddressGapDetect = ObjectOfDataRanges_tempSort[i-1].EndAddress
					}
					if (ObjectOfDataRanges_tempSort[i].StartAddress > HighestEndAddressGapDetect+1n) {
						let StartAddress = HighestEndAddressGapDetect+1n
						let Length = ObjectOfDataRanges_tempSort[i].StartAddress - HighestEndAddressGapDetect-1n
						let EndAddress = Length + HighestEndAddressGapDetect
						GapList.push({
							StartAddress: StartAddress,
							Length: Length,
							EndAddress: EndAddress,
							Description: "Gap",
							SourceText: BigIntToStringSignedHex(StartAddress) + "\t~" + BigIntToStringSignedHex(EndAddress) + "\tGap",
							Type: "Gap",
							ConflictsWith: [], //This needed to be here else we had to check if this even exists when sorting, making it slow.
							SVGBarXPos: 0n
						})
					}
				}
				if (document.getElementById("Filter_Gap").checked) {
					ObjectOfDataRanges = ObjectOfDataRanges.concat(GapList)
				}
			}
			SavedAddresses = ObjectOfDataRanges
		} else {
			ObjectOfDataRanges = SavedAddresses
		}
		if (document.getElementById("Setting_ViewMode_Table").checked) {
			document.getElementById("Output_AddressInfo_Text").value = ""
			let OutputTable = document.getElementById("Output_AddressInfo_Table")
			while (OutputTable.lastElementChild) {
				OutputTable.removeChild(OutputTable.lastElementChild)
			}
			ObjectOfDataRanges = ObjectOfDataRanges.filter(item => document.getElementById("Filter_" + item.Type).checked)
			let ReverseSort = document.getElementById("SortOption_Reverse").checked ? -1 : 1
			if (document.getElementById("SortOption_ByAddr").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				ObjectOfDataRanges.sort((a,b) => Number((a.StartAddress-b.StartAddress))*ReverseSort)
			} else if (document.getElementById("SortOption_Size").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				ObjectOfDataRanges.sort((a,b) => Number((a.Length-b.Length))*ReverseSort)
			} else if (document.getElementById("SortOption_Discription").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				ObjectOfDataRanges.sort((a,b) => {
					if (a.Description === b.Description) {
						return 0
					}
					return ((a.Description < b.Description) ? -1 : 1)*ReverseSort
				})
			} else if (document.getElementById("SortOption_Type").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				ObjectOfDataRanges.sort((a,b) => {
					if (a.Type === b.Type) {
						return 0
					}
					return ((a.Type < b.Type) ? -1 : 1)*ReverseSort
				})
			} else if (document.getElementById("SortOption_OverlapCount").selected) {
				document.getElementById("SortOption_Reverse").disabled = false
				ObjectOfDataRanges.sort((a,b) => Number((a.ConflictsWith.Length-b.ConflictsWith.Length))*ReverseSort)
			} else {
				document.getElementById("SortOption_Reverse").disabled = true
			}
			let PlainTextOutput = ""
			
			let Output_TableHeaderRow = document.createElement("tr")
			
			let Output_TableHeader_StartAddress = document.createElement("th")
			Output_TableHeader_StartAddress.appendChild(document.createTextNode("Starting address"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_StartAddress)
			
			let Output_TableHeader_LengthAndEnd = document.createElement("th")
			Output_TableHeader_LengthAndEnd.appendChild(document.createTextNode("Length/ending address"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_LengthAndEnd)
			
			let Output_TableHeader_Description = document.createElement("th")
			Output_TableHeader_Description.appendChild(document.createTextNode("Description"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_Description)
			
			let Output_TableHeader_Overlap = document.createElement("th")
			Output_TableHeader_Overlap.appendChild(document.createTextNode("Overlap"))
			Output_TableHeaderRow.appendChild(Output_TableHeader_Overlap)
			
			document.getElementById("Output_AddressInfo_Table").appendChild(Output_TableHeaderRow)
			
			ObjectOfDataRanges.forEach((item, index, Arr) => {
				PlainTextOutput += BigIntToStringSignedHex(item.StartAddress) + "\t"
				if (document.getElementById("PlaintextSetting_Output_Size").selected) {
					PlainTextOutput += item.Length.toString(10)
				} else if (document.getElementById("PlaintextSetting_Output_Ending").selected) {
					PlainTextOutput += "~" + BigIntToStringSignedHex(item.EndAddress)
				} else if (document.getElementById("PlaintextSetting_Output_SizeAndEnding").selected) {
					PlainTextOutput += item.Length.toString(10) + "/~" + BigIntToStringSignedHex(item.EndAddress)
				}
				PlainTextOutput += "\t" + item.Description
				
				let TableItemRow = document.createElement("tr")
				
				let TableItem_StartAddress = document.createElement("td")
				TableItem_StartAddress.style.fontFamily = "monospace"
				TableItem_StartAddress.style.backgroundColor = ColorCodedStatus[item.Type]
				TableItem_StartAddress.appendChild(document.createTextNode(BigIntToStringSignedHex(item.StartAddress)))
				TableItemRow.appendChild(TableItem_StartAddress)
				
				let TableItem_LengthEnd = document.createElement("td")
				TableItem_LengthEnd.style.fontFamily = "monospace"
				TableItem_LengthEnd.style.backgroundColor = ColorCodedStatus[item.Type]
				TableItem_LengthEnd.appendChild(document.createTextNode(item.Length.toString(10) + "/" + BigIntToStringSignedHex(item.EndAddress)))
				TableItemRow.appendChild(TableItem_LengthEnd)
				
				let TableItem_Description = document.createElement("td")
				TableItem_Description.style.fontFamily = "monospace"
				TableItem_Description.style.backgroundColor = ColorCodedStatus[item.Type]
				TableItem_Description.appendChild(document.createTextNode(item.Description))
				TableItemRow.appendChild(TableItem_Description)
				
				let TableItem_Overlap = document.createElement("td")
				TableItem_Overlap.style.backgroundColor = ColorCodedStatus[item.Type]
				
				TableItemRow.appendChild(TableItem_Overlap)
				
				if (document.getElementById("PlaintextSetting_Output_OverlapStatus").checked) {
					if (item.ConflictsWith.length != 0) {
						PlainTextOutput += "\n\t;^Overlaps with:\n"
						
						let OverlappedItem_Table = document.createElement("table")
						let OverlappedItem_HeaderRow = document.createElement("tr")
						
						let OverlappedItem_HeaderStart = document.createElement("th")
						OverlappedItem_HeaderStart.appendChild(document.createTextNode("Starting address"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_HeaderStart)
						
						let OverlappedItem_LengthEnd = document.createElement("th")
						OverlappedItem_LengthEnd.appendChild(document.createTextNode("length/end"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_LengthEnd)
						
						let OverlappedItem_Description = document.createElement("th")
						OverlappedItem_Description.appendChild(document.createTextNode("Description"))
						OverlappedItem_HeaderRow.appendChild(OverlappedItem_Description)
						
						OverlappedItem_Table.appendChild(OverlappedItem_HeaderRow)
						
						item.ConflictsWith.forEach((overlapped, index2, Arr2) => {
							PlainTextOutput += "\t;" + BigIntToStringSignedHex(overlapped.StartAddress) + "\t"
							if (document.getElementById("PlaintextSetting_Output_Size").selected) {
								PlainTextOutput += overlapped.Length.toString(10)
							} else if (document.getElementById("PlaintextSetting_Output_Ending").selected) {
								PlainTextOutput += "~" + BigIntToStringSignedHex(overlapped.EndAddress)
							} else if (document.getElementById("PlaintextSetting_Output_SizeAndEnding").selected) {
								PlainTextOutput += overlapped.Length.toString(10) + "/~" + BigIntToStringSignedHex(overlapped.EndAddress)
							}
							PlainTextOutput += "\t" + overlapped.Description
							if (index2 != Arr2.length-1) {
								PlainTextOutput += "\n"
							}
							
							let OverlappedItem_RowConflict = document.createElement("tr")
							
							let OverlappedItem_Start = document.createElement("td")
							OverlappedItem_Start.style.fontFamily = "monospace"
							OverlappedItem_Start.appendChild(document.createTextNode(BigIntToStringSignedHex(overlapped.StartAddress)))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_Start)
							
							let OverlappedItem_LengthEnd = document.createElement("td")
							OverlappedItem_LengthEnd.style.fontFamily = "monospace"
							OverlappedItem_LengthEnd.appendChild(document.createTextNode(overlapped.Length.toString(10) + "/" + BigIntToStringSignedHex(overlapped.EndAddress)))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_LengthEnd)
							
							let OverlappedItem_Description = document.createElement("td")
							OverlappedItem_Description.style.fontFamily = "monospace"
							OverlappedItem_Description.appendChild(document.createTextNode(overlapped.Description))
							OverlappedItem_RowConflict.appendChild(OverlappedItem_Description)
							
							OverlappedItem_Table.appendChild(OverlappedItem_RowConflict)
						})
						TableItem_Overlap.appendChild(OverlappedItem_Table)
					}
				}
				
				if (index != Arr.length-1) {
					PlainTextOutput += "\n"
				}
				document.getElementById("Output_AddressInfo_Table").appendChild(TableItemRow)
			})
			document.getElementById("Output_AddressInfo_Text").value = PlainTextOutput
		} else {
			//Clear the graph
			SVG_GraphElement.style.width = (Setting_ByteView_NumberOfColumns*Setting_ByteView_SVGGridSizeFactor)
			SVG_GraphElement.style.height = (Setting_ByteView_NumberOfRows*Setting_ByteView_SVGGridSizeFactor).toString(10) + "px"
			while (SVG_GraphElement.lastElementChild) {
				SVG_GraphElement.removeChild(SVG_GraphElement.lastElementChild)
			}
			//Variables needed
			let StartingAddressViewing = ParseBigIntValue(document.getElementById("SVGAddressView").value, 16)
			
			
			if (NeedsToUpdateSVGOrder) {
				//Sort so when overlaps occurs, what appears first in the overlap group appears on the leftmost.
				SavedSortedForSVGOrder = SavedAddresses.toSorted((a,b) => Number((a.StartAddress-b.StartAddress)))
				
				NeedsToUpdateSVGOrder = false
				if (SavedSortedForSVGOrder.length > 1) {
					//Adjust X position so overlapped bars are placed to the right until they don't
					let l = SavedSortedForSVGOrder.length
					for (let i=0; i<l; i++) {
						let isOverlappingXY = false
						do {
							isOverlappingXY = false
							for (let i2=0; i2<i && (!isOverlappingXY); i2++) { //Loop all previous before current index
								let isAddrOverlapping = CheckOverlap(SavedSortedForSVGOrder[i].StartAddress, SavedSortedForSVGOrder[i].EndAddress, SavedSortedForSVGOrder[i2].StartAddress, SavedSortedForSVGOrder[i2].EndAddress)
								let isSVGBarXPosOverlapping = SavedSortedForSVGOrder[i].SVGBarXPos == SavedSortedForSVGOrder[i2].SVGBarXPos
								if (isAddrOverlapping && isSVGBarXPosOverlapping) {
									isOverlappingXY = true
								}
							}
							if (isOverlappingXY) {
								SavedSortedForSVGOrder[i].SVGBarXPos++
							}
						} while (isOverlappingXY) //If still overlapping, repeat
					}
				}
			}
			
			//Line seperator
			for (let i=0n; i<Setting_ByteView_NumberOfRows; i++) {
				let AddressSeperatorLine = createSVGElement("line")
				AddressSeperatorLine.setAttribute("stroke", "#ffffff")
				AddressSeperatorLine.setAttribute("x1", "0")
				AddressSeperatorLine.setAttribute("x2", (Setting_ByteView_NumberOfColumns*Setting_ByteView_SVGGridSizeFactor).toString(10))
				AddressSeperatorLine.setAttribute("y1", (i*Setting_ByteView_SVGGridSizeFactor).toString(10))
				AddressSeperatorLine.setAttribute("y2", (i*Setting_ByteView_SVGGridSizeFactor).toString(10))
				SVG_GraphElement.appendChild(AddressSeperatorLine)
			}
			
			
			//Generate bars representing an address range
			SavedSortedForSVGOrder.forEach(item => {
				let AddressRect = createSVGElement("rect")
				AddressRect.setAttribute("rx", "8")
				AddressRect.setAttribute("ry", "8")
				AddressRect.setAttribute("fill", ColorCodedStatus[item.Type])
				
				let TopPos = BigintClamp((item.StartAddress-StartingAddressViewing)*Setting_ByteView_SVGGridSizeFactor, -Setting_ByteView_SVGGridSizeFactor, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
				let BottomPos = BigintClamp((item.EndAddress-StartingAddressViewing+1n)*Setting_ByteView_SVGGridSizeFactor, -Setting_ByteView_SVGGridSizeFactor, (Setting_ByteView_NumberOfRows+1n)*Setting_ByteView_SVGGridSizeFactor)
				let Height = BottomPos-TopPos
				
				AddressRect.setAttribute("height", Height.toString(10))
				AddressRect.setAttribute("width", Setting_ByteView_SVGGridSizeFactor.toString(10))
				
				AddressRect.setAttribute("x", (50n + item.SVGBarXPos*Setting_ByteView_SVGGridSizeFactor).toString(10))
				AddressRect.setAttribute("y", TopPos.toString(10))
				
				let TitleHover = createSVGElement("title")
				TitleHover.appendChild(document.createTextNode(item.SourceText))
				AddressRect.appendChild(TitleHover)
				
				SVG_GraphElement.appendChild(AddressRect)
			})
			
			
			//Generate addresses text
			for (let i=0n; i<Setting_ByteView_NumberOfRows; i++) {
				let AddressText = createSVGElement("text")
				AddressText.setAttribute("stroke", "#ffffff")
				AddressText.setAttribute("font-weight", "lighter")
				AddressText.setAttribute("text-anchor", "left")
				AddressText.setAttribute("alignment-baseline", "hanging")
				AddressText.setAttribute("font-family", "monospace")
				AddressText.appendChild(document.createTextNode(BigIntToStringSignedHex((StartingAddressViewing+i))))
				AddressText.setAttribute("transform", "translate(0, " + (i*Setting_ByteView_SVGGridSizeFactor).toString(10) + ")")
				SVG_GraphElement.appendChild(AddressText)
			}
			
		}
	}
//helper
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
	function ModifyCheckboxes(node, checkState) {
		[...node.querySelectorAll("input[type=checkbox]")].forEach(ele => {
			if (checkState == 0 || checkState == 1) {
				ele.checked = checkState
			} else {
				ele.checked = !ele.checked
			}
		});
	}
	
	function keyHandler_Tab(e) {

		let target;
		if (!e) e = window.event;
		if (e.target) target = e.target;
		else if (e.srcElement) target = e.srcElement;

		if(e.keyCode == 9) {
			if (document.selection) {
				e.preventDefault()
				target.focus();
				sel = document.selection.createRange();
				sel.text = '\t';
			} else if (target.selectionStart || target.selectionStart === 0) {
				e.preventDefault()
				let startPos = target.selectionStart;
				let endPos = target.selectionEnd;
				target.value = target.value.substring(0, startPos) + '\t' + target.value.substring(endPos, target.value.length);
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.

				target.selectionStart = startPos + 1;
				target.selectionEnd = startPos + 1;

			} else {
				e.preventDefault()
				target.value += '\t';
			}

			if(e.preventDefault) {
				e.preventDefault();
				target.oninput()	//Fix an issue where if a tab is inserted and results the format being valid, the function to display the address won't update.
			}
			return false;
		}
	}
	//Check if two ranges overlap.
	//Given 2 ranges:
	//Range_A: A_Start and A_End
	//Range_B: B_Start and B_End
	//If B_End is touching A_Start, then Range_B is at the lowest position (or Range_A at the highest position) that would count as an overlap
	//If B_Start is touching A_End, then Range_B is at the highest position (or Range_A is at the lowest position) that would count as an overlap
		function CheckOverlap(A_Start, A_End, B_Start, B_End) {
			if (B_End >= A_Start&&B_Start <= A_End) {
				return true
			} else {
				return false
			}
		}
	function createSVGElement(tag) { //https://stackoverflow.com/questions/57894500/why-is-it-necessary-to-use-document-createelementns-when-adding-svg-tags-to
		return document.createElementNS('http://www.w3.org/2000/svg', tag)
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
			return num <= min ? min : num >= max ? max : num;
	}
	function BigIntToStringSignedHex(BigIntVal) {
		//Converts a bigint value into a signed ASM-styled hex number:
		//16n -> "$10"
		//-16n -> "-$10"
		let StringOutput = ""
		if (BigIntVal >= 0n) {
			StringOutput = "$" + BigIntVal.toString(16).toUpperCase()
		} else {
			StringOutput = "-$" + (BigIntVal*-1n).toString(16).toUpperCase()
		}
		return StringOutput
	}
</script>